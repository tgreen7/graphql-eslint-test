import { parseCode } from '@graphql-tools/graphql-tag-pluck';
import { Kind, visit, validate, TokenKind, isScalarType, isInterfaceType, TypeInfo, visitWithTypeInfo, isObjectType as isObjectType$1, Source, isNonNullType, isListType, GraphQLObjectType, GraphQLInterfaceType, GraphQLSchema, GraphQLError } from 'graphql';
import { validateSDL } from 'graphql/validation/validate';
import { statSync, existsSync, readFileSync } from 'fs';
import { dirname, extname, basename, relative, resolve } from 'path';
import lowerCase from 'lodash.lowercase';
import chalk from 'chalk';
import { getDocumentNodeFromSchema, asArray, parseGraphQLSDL } from '@graphql-tools/utils';
import { valueFromASTUntyped } from 'graphql/utilities/valueFromASTUntyped';
import depthLimit from 'graphql-depth-limit';
import debugFactory from 'debug';
import fastGlob from 'fast-glob';
import { loadConfigSync, GraphQLConfig } from 'graphql-config';
import { CodeFileLoader } from '@graphql-tools/code-file-loader';
import { RuleTester, Linter } from 'eslint';
import { codeFrameColumns } from '@babel/code-frame';

const RELEVANT_KEYWORDS = ['gql`', 'graphql`', '/* GraphQL */'];
const blocksMap = new Map();
const processor = {
    supportsAutofix: true,
    preprocess(code, filePath) {
        if (RELEVANT_KEYWORDS.every(keyword => !code.includes(keyword))) {
            return [code];
        }
        const extractedDocuments = parseCode({
            code,
            filePath,
            options: {
                globalGqlIdentifierName: ['gql', 'graphql'],
                skipIndent: true,
            },
        });
        const blocks = extractedDocuments.map(item => ({
            filename: 'document.graphql',
            text: item.content,
            lineOffset: item.loc.start.line - 1,
            offset: item.start + 1,
        }));
        blocksMap.set(filePath, blocks);
        return [code, ...blocks];
    },
    postprocess(messages, filePath) {
        const blocks = blocksMap.get(filePath) || [];
        for (let i = 0; i < blocks.length; i += 1) {
            const { lineOffset, offset } = blocks[i];
            for (const message of messages[i]) {
                message.line += lineOffset;
                message.endLine += lineOffset;
                if (message.fix) {
                    message.fix.range[0] += offset;
                    message.fix.range[1] += offset;
                }
                for (const suggestion of message.suggestions || []) {
                    suggestion.fix.range[0] += offset;
                    suggestion.fix.range[1] += offset;
                }
            }
        }
        return messages.flat();
    },
};

function requireSiblingsOperations(ruleId, context) {
    const { siblingOperations } = context.parserServices;
    if (!siblingOperations.available) {
        throw new Error(`Rule \`${ruleId}\` requires \`parserOptions.operations\` to be set and loaded. See https://bit.ly/graphql-eslint-operations for more info`);
    }
    return siblingOperations;
}
function requireGraphQLSchemaFromContext(ruleId, context) {
    const { schema } = context.parserServices;
    if (!schema) {
        throw new Error(`Rule \`${ruleId}\` requires \`parserOptions.schema\` to be set and loaded. See https://bit.ly/graphql-eslint-schema for more info`);
    }
    else if (schema instanceof Error) {
        throw schema;
    }
    return schema;
}
const logger = {
    // eslint-disable-next-line no-console
    error: (...args) => console.error(chalk.red('error'), '[graphql-eslint]', chalk(...args)),
    // eslint-disable-next-line no-console
    warn: (...args) => console.warn(chalk.yellow('warning'), '[graphql-eslint]', chalk(...args)),
};
const normalizePath = (path) => (path || '').replace(/\\/g, '/');
/**
 * https://github.com/prettier/eslint-plugin-prettier/blob/76bd45ece6d56eb52f75db6b4a1efdd2efb56392/eslint-plugin-prettier.js#L71
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
const getOnDiskFilepath = (filepath) => {
    try {
        if (statSync(filepath).isFile()) {
            return filepath;
        }
    }
    catch (err) {
        // https://github.com/eslint/eslint/issues/11989
        if (err.code === 'ENOTDIR') {
            return getOnDiskFilepath(dirname(filepath));
        }
    }
    return filepath;
};
const getTypeName = (node) => ('type' in node ? getTypeName(node.type) : node.name.value);
const TYPES_KINDS = [
    Kind.OBJECT_TYPE_DEFINITION,
    Kind.INTERFACE_TYPE_DEFINITION,
    Kind.ENUM_TYPE_DEFINITION,
    Kind.SCALAR_TYPE_DEFINITION,
    Kind.INPUT_OBJECT_TYPE_DEFINITION,
    Kind.UNION_TYPE_DEFINITION,
];
const pascalCase = (str) => lowerCase(str)
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
const camelCase = (str) => {
    const result = pascalCase(str);
    return result.charAt(0).toLowerCase() + result.slice(1);
};
const convertCase = (style, str) => {
    switch (style) {
        case 'camelCase':
            return camelCase(str);
        case 'PascalCase':
            return pascalCase(str);
        case 'snake_case':
            return lowerCase(str).replace(/ /g, '_');
        case 'UPPER_CASE':
            return lowerCase(str).replace(/ /g, '_').toUpperCase();
        case 'kebab-case':
            return lowerCase(str).replace(/ /g, '-');
    }
};
function getLocation(start, fieldName = '') {
    const { line, column } = start;
    return {
        start: {
            line,
            column,
        },
        end: {
            line,
            column: column + fieldName.length,
        },
    };
}
const REPORT_ON_FIRST_CHARACTER = { column: 0, line: 1 };
const ARRAY_DEFAULT_OPTIONS = {
    type: 'array',
    uniqueItems: true,
    minItems: 1,
    items: {
        type: 'string',
    },
};
const englishJoinWords = words => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(words);

function validateDocument(context, schema = null, documentNode, rule) {
    if (documentNode.definitions.length === 0) {
        return;
    }
    try {
        const validationErrors = schema
            ? validate(schema, documentNode, [rule])
            : validateSDL(documentNode, null, [rule]);
        for (const error of validationErrors) {
            const { line, column } = error.locations[0];
            const sourceCode = context.getSourceCode();
            const { tokens } = sourceCode.ast;
            const token = tokens.find(token => token.loc.start.line === line && token.loc.start.column === column - 1);
            let loc = {
                line,
                column: column - 1,
            };
            if (token) {
                loc =
                    // if cursor on `@` symbol than use next node
                    token.type === '@' ? sourceCode.getNodeByRangeIndex(token.range[1] + 1).loc : token.loc;
            }
            context.report({
                loc,
                message: error.message,
            });
        }
    }
    catch (e) {
        context.report({
            loc: REPORT_ON_FIRST_CHARACTER,
            message: e.message,
        });
    }
}
const getFragmentDefsAndFragmentSpreads = (node) => {
    const fragmentDefs = new Set();
    const fragmentSpreads = new Set();
    const visitor = {
        FragmentDefinition(node) {
            fragmentDefs.add(node.name.value);
        },
        FragmentSpread(node) {
            fragmentSpreads.add(node.name.value);
        },
    };
    visit(node, visitor);
    return { fragmentDefs, fragmentSpreads };
};
const getMissingFragments = (node) => {
    const { fragmentDefs, fragmentSpreads } = getFragmentDefsAndFragmentSpreads(node);
    return [...fragmentSpreads].filter(name => !fragmentDefs.has(name));
};
const handleMissingFragments = ({ ruleId, context, node }) => {
    const missingFragments = getMissingFragments(node);
    if (missingFragments.length > 0) {
        const siblings = requireSiblingsOperations(ruleId, context);
        const fragmentsToAdd = [];
        for (const fragmentName of missingFragments) {
            const [foundFragment] = siblings.getFragment(fragmentName).map(source => source.document);
            if (foundFragment) {
                fragmentsToAdd.push(foundFragment);
            }
        }
        if (fragmentsToAdd.length > 0) {
            // recall fn to make sure to add fragments inside fragments
            return handleMissingFragments({
                ruleId,
                context,
                node: {
                    kind: Kind.DOCUMENT,
                    definitions: [...node.definitions, ...fragmentsToAdd],
                },
            });
        }
    }
    return node;
};
const validationToRule = (ruleId, ruleName, docs, getDocumentNode, schema = []) => {
    let ruleFn = null;
    try {
        ruleFn = require(`graphql/validation/rules/${ruleName}Rule`)[`${ruleName}Rule`];
    }
    catch (_a) {
        try {
            ruleFn = require(`graphql/validation/rules/${ruleName}`)[`${ruleName}Rule`];
        }
        catch (_b) {
            ruleFn = require('graphql/validation')[`${ruleName}Rule`];
        }
    }
    return {
        [ruleId]: {
            meta: {
                docs: {
                    recommended: true,
                    ...docs,
                    graphQLJSRuleName: ruleName,
                    url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${ruleId}.md`,
                    description: `${docs.description}\n\n> This rule is a wrapper around a \`graphql-js\` validation function.`,
                },
                schema,
            },
            create(context) {
                if (!ruleFn) {
                    logger.warn(`Rule "${ruleId}" depends on a GraphQL validation rule "${ruleName}" but it's not available in the "graphql" version you are using. Skipping…`);
                    return {};
                }
                return {
                    Document(node) {
                        const schema = docs.requiresSchema ? requireGraphQLSchemaFromContext(ruleId, context) : null;
                        const documentNode = getDocumentNode
                            ? getDocumentNode({ ruleId, context, node: node.rawNode() })
                            : node.rawNode();
                        validateDocument(context, schema, documentNode, ruleFn);
                    },
                };
            },
        },
    };
};
const GRAPHQL_JS_VALIDATIONS = Object.assign({}, validationToRule('executable-definitions', 'ExecutableDefinitions', {
    category: 'Operations',
    description: 'A GraphQL document is only valid for execution if all definitions are either operation or fragment definitions.',
    requiresSchema: true,
}), validationToRule('fields-on-correct-type', 'FieldsOnCorrectType', {
    category: 'Operations',
    description: 'A GraphQL document is only valid if all fields selected are defined by the parent type, or are an allowed meta field such as `__typename`.',
    requiresSchema: true,
}), validationToRule('fragments-on-composite-type', 'FragmentsOnCompositeTypes', {
    category: 'Operations',
    description: 'Fragments use a type condition to determine if they apply, since fragments can only be spread into a composite type (object, interface, or union), the type condition must also be a composite type.',
    requiresSchema: true,
}), validationToRule('known-argument-names', 'KnownArgumentNames', {
    category: ['Schema', 'Operations'],
    description: 'A GraphQL field is only valid if all supplied arguments are defined by that field.',
    requiresSchema: true,
}), validationToRule('known-directives', 'KnownDirectives', {
    category: ['Schema', 'Operations'],
    description: 'A GraphQL document is only valid if all `@directive`s are known by the schema and legally positioned.',
    requiresSchema: true,
    examples: [
        {
            title: 'Valid',
            usage: [{ ignoreClientDirectives: ['client'] }],
            code: /* GraphQL */ `
            {
              product {
                someClientField @client
              }
            }
          `,
        },
    ],
}, ({ context, node: documentNode }) => {
    const { ignoreClientDirectives = [] } = context.options[0] || {};
    if (ignoreClientDirectives.length === 0) {
        return documentNode;
    }
    return visit(documentNode, {
        Field(node) {
            return {
                ...node,
                directives: node.directives.filter(directive => !ignoreClientDirectives.includes(directive.name.value)),
            };
        },
    });
}, {
    type: 'array',
    maxItems: 1,
    items: {
        type: 'object',
        additionalProperties: false,
        required: ['ignoreClientDirectives'],
        properties: {
            ignoreClientDirectives: ARRAY_DEFAULT_OPTIONS,
        },
    },
}), validationToRule('known-fragment-names', 'KnownFragmentNames', {
    category: 'Operations',
    description: 'A GraphQL document is only valid if all `...Fragment` fragment spreads refer to fragments defined in the same document.',
    requiresSchema: true,
    requiresSiblings: true,
    examples: [
        {
            title: 'Incorrect',
            code: /* GraphQL */ `
            query {
              user {
                id
                ...UserFields # fragment not defined in the document
              }
            }
          `,
        },
        {
            title: 'Correct',
            code: /* GraphQL */ `
            fragment UserFields on User {
              firstName
              lastName
            }

            query {
              user {
                id
                ...UserFields
              }
            }
          `,
        },
        {
            title: 'Correct (`UserFields` fragment located in a separate file)',
            code: /* GraphQL */ `
            # user.gql
            query {
              user {
                id
                ...UserFields
              }
            }

            # user-fields.gql
            fragment UserFields on User {
              id
            }
          `,
        },
    ],
}, handleMissingFragments), validationToRule('known-type-names', 'KnownTypeNames', {
    category: ['Schema', 'Operations'],
    description: 'A GraphQL document is only valid if referenced types (specifically variable definitions and fragment conditions) are defined by the type schema.',
    requiresSchema: true,
}), validationToRule('lone-anonymous-operation', 'LoneAnonymousOperation', {
    category: 'Operations',
    description: 'A GraphQL document is only valid if when it contains an anonymous operation (the query short-hand) that it contains only that one operation definition.',
    requiresSchema: true,
}), validationToRule('lone-schema-definition', 'LoneSchemaDefinition', {
    category: 'Schema',
    description: 'A GraphQL document is only valid if it contains only one schema definition.',
}), validationToRule('no-fragment-cycles', 'NoFragmentCycles', {
    category: 'Operations',
    description: 'A GraphQL fragment is only valid when it does not have cycles in fragments usage.',
    requiresSchema: true,
}), validationToRule('no-undefined-variables', 'NoUndefinedVariables', {
    category: 'Operations',
    description: 'A GraphQL operation is only valid if all variables encountered, both directly and via fragment spreads, are defined by that operation.',
    requiresSchema: true,
    requiresSiblings: true,
}, handleMissingFragments), validationToRule('no-unused-fragments', 'NoUnusedFragments', {
    category: 'Operations',
    description: 'A GraphQL document is only valid if all fragment definitions are spread within operations, or spread within other fragments spread within operations.',
    requiresSchema: true,
    requiresSiblings: true,
}, ({ ruleId, context, node }) => {
    const siblings = requireSiblingsOperations(ruleId, context);
    const FilePathToDocumentsMap = [...siblings.getOperations(), ...siblings.getFragments()].reduce((map, { filePath, document }) => {
        var _a;
        (_a = map[filePath]) !== null && _a !== void 0 ? _a : (map[filePath] = []);
        map[filePath].push(document);
        return map;
    }, Object.create(null));
    const getParentNode = (currentFilePath, node) => {
        const { fragmentDefs } = getFragmentDefsAndFragmentSpreads(node);
        if (fragmentDefs.size === 0) {
            return node;
        }
        // skip iteration over documents for current filepath
        delete FilePathToDocumentsMap[currentFilePath];
        for (const [filePath, documents] of Object.entries(FilePathToDocumentsMap)) {
            const missingFragments = getMissingFragments({
                kind: Kind.DOCUMENT,
                definitions: documents,
            });
            const isCurrentFileImportFragment = missingFragments.some(fragment => fragmentDefs.has(fragment));
            if (isCurrentFileImportFragment) {
                return getParentNode(filePath, {
                    kind: Kind.DOCUMENT,
                    definitions: [...node.definitions, ...documents],
                });
            }
        }
        return node;
    };
    return getParentNode(context.getFilename(), node);
}), validationToRule('no-unused-variables', 'NoUnusedVariables', {
    category: 'Operations',
    description: 'A GraphQL operation is only valid if all variables defined by an operation are used, either directly or within a spread fragment.',
    requiresSchema: true,
    requiresSiblings: true,
}, handleMissingFragments), validationToRule('overlapping-fields-can-be-merged', 'OverlappingFieldsCanBeMerged', {
    category: 'Operations',
    description: 'A selection set is only valid if all fields (including spreading any fragments) either correspond to distinct response names or can be merged without ambiguity.',
    requiresSchema: true,
}), validationToRule('possible-fragment-spread', 'PossibleFragmentSpreads', {
    category: 'Operations',
    description: 'A fragment spread is only valid if the type condition could ever possibly be true: if there is a non-empty intersection of the possible parent types, and possible types which pass the type condition.',
    requiresSchema: true,
}), validationToRule('possible-type-extension', 'PossibleTypeExtensions', {
    category: 'Schema',
    description: 'A type extension is only valid if the type is defined and has the same kind.',
    // TODO: add in graphql-eslint v4
    recommended: false,
    requiresSchema: true,
    isDisabledForAllConfig: true,
}), validationToRule('provided-required-arguments', 'ProvidedRequiredArguments', {
    category: ['Schema', 'Operations'],
    description: 'A field or directive is only valid if all required (non-null without a default value) field arguments have been provided.',
    requiresSchema: true,
}), validationToRule('scalar-leafs', 'ScalarLeafs', {
    category: 'Operations',
    description: 'A GraphQL document is valid only if all leaf fields (fields without sub selections) are of scalar or enum types.',
    requiresSchema: true,
}), validationToRule('one-field-subscriptions', 'SingleFieldSubscriptions', {
    category: 'Operations',
    description: 'A GraphQL subscription is valid only if it contains a single root field.',
    requiresSchema: true,
}), validationToRule('unique-argument-names', 'UniqueArgumentNames', {
    category: 'Operations',
    description: 'A GraphQL field or directive is only valid if all supplied arguments are uniquely named.',
    requiresSchema: true,
}), validationToRule('unique-directive-names', 'UniqueDirectiveNames', {
    category: 'Schema',
    description: 'A GraphQL document is only valid if all defined directives have unique names.',
}), validationToRule('unique-directive-names-per-location', 'UniqueDirectivesPerLocation', {
    category: ['Schema', 'Operations'],
    description: 'A GraphQL document is only valid if all non-repeatable directives at a given location are uniquely named.',
    requiresSchema: true,
}), validationToRule('unique-enum-value-names', 'UniqueEnumValueNames', {
    category: 'Schema',
    description: 'A GraphQL enum type is only valid if all its values are uniquely named.',
    recommended: false,
    isDisabledForAllConfig: true,
}), validationToRule('unique-field-definition-names', 'UniqueFieldDefinitionNames', {
    category: 'Schema',
    description: 'A GraphQL complex type is only valid if all its fields are uniquely named.',
}), validationToRule('unique-input-field-names', 'UniqueInputFieldNames', {
    category: 'Operations',
    description: 'A GraphQL input object value is only valid if all supplied fields are uniquely named.',
}), validationToRule('unique-operation-types', 'UniqueOperationTypes', {
    category: 'Schema',
    description: 'A GraphQL document is only valid if it has only one type per operation.',
}), validationToRule('unique-type-names', 'UniqueTypeNames', {
    category: 'Schema',
    description: 'A GraphQL document is only valid if all defined types have unique names.',
}), validationToRule('unique-variable-names', 'UniqueVariableNames', {
    category: 'Operations',
    description: 'A GraphQL operation is only valid if all its variables are uniquely named.',
    requiresSchema: true,
}), validationToRule('value-literals-of-correct-type', 'ValuesOfCorrectType', {
    category: 'Operations',
    description: 'A GraphQL document is only valid if all value literals are of the type expected at their position.',
    requiresSchema: true,
}), validationToRule('variables-are-input-types', 'VariablesAreInputTypes', {
    category: 'Operations',
    description: 'A GraphQL operation is only valid if all the variables it defines are of input types (scalar, enum, or input object).',
    requiresSchema: true,
}), validationToRule('variables-in-allowed-position', 'VariablesInAllowedPosition', {
    category: 'Operations',
    description: 'Variables passed to field arguments conform to type.',
    requiresSchema: true,
}));

const RULE_ID = 'alphabetize';
const fieldsEnum = [
    Kind.OBJECT_TYPE_DEFINITION,
    Kind.INTERFACE_TYPE_DEFINITION,
    Kind.INPUT_OBJECT_TYPE_DEFINITION,
];
const valuesEnum = [Kind.ENUM_TYPE_DEFINITION];
const selectionsEnum = [
    Kind.OPERATION_DEFINITION,
    Kind.FRAGMENT_DEFINITION,
];
const variablesEnum = [Kind.OPERATION_DEFINITION];
const argumentsEnum = [
    Kind.FIELD_DEFINITION,
    Kind.FIELD,
    Kind.DIRECTIVE_DEFINITION,
    Kind.DIRECTIVE,
];
const rule = {
    meta: {
        type: 'suggestion',
        fixable: 'code',
        docs: {
            category: ['Schema', 'Operations'],
            description: 'Enforce arrange in alphabetical order for type fields, enum values, input object fields, operation selections and more.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID}.md`,
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ fields: [Kind.OBJECT_TYPE_DEFINITION] }],
                    code: /* GraphQL */ `
            type User {
              password: String
              firstName: String! # should be before "password"
              age: Int # should be before "firstName"
              lastName: String!
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ fields: [Kind.OBJECT_TYPE_DEFINITION] }],
                    code: /* GraphQL */ `
            type User {
              age: Int
              firstName: String!
              lastName: String!
              password: String
            }
          `,
                },
                {
                    title: 'Incorrect',
                    usage: [{ values: [Kind.ENUM_TYPE_DEFINITION] }],
                    code: /* GraphQL */ `
            enum Role {
              SUPER_ADMIN
              ADMIN # should be before "SUPER_ADMIN"
              USER
              GOD # should be before "USER"
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ values: [Kind.ENUM_TYPE_DEFINITION] }],
                    code: /* GraphQL */ `
            enum Role {
              ADMIN
              GOD
              SUPER_ADMIN
              USER
            }
          `,
                },
                {
                    title: 'Incorrect',
                    usage: [{ selections: [Kind.OPERATION_DEFINITION] }],
                    code: /* GraphQL */ `
            query {
              me {
                firstName
                lastName
                email # should be before "lastName"
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ selections: [Kind.OPERATION_DEFINITION] }],
                    code: /* GraphQL */ `
            query {
              me {
                email
                firstName
                lastName
              }
            }
          `,
                },
            ],
            configOptions: {
                schema: [
                    {
                        fields: fieldsEnum,
                        values: valuesEnum,
                        arguments: argumentsEnum,
                        // TODO: add in graphql-eslint v4
                        // definitions: true,
                    },
                ],
                operations: [
                    {
                        selections: selectionsEnum,
                        variables: variablesEnum,
                        arguments: [Kind.FIELD, Kind.DIRECTIVE],
                    },
                ],
            },
        },
        messages: {
            [RULE_ID]: '`{{ currName }}` should be before {{ prevName }}.',
        },
        schema: {
            type: 'array',
            minItems: 1,
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                minProperties: 1,
                properties: {
                    fields: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        items: {
                            enum: fieldsEnum,
                        },
                        description: 'Fields of `type`, `interface`, and `input`.',
                    },
                    values: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        items: {
                            enum: valuesEnum,
                        },
                        description: 'Values of `enum`.',
                    },
                    selections: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        items: {
                            enum: selectionsEnum,
                        },
                        description: 'Selections of `fragment` and operations `query`, `mutation` and `subscription`.',
                    },
                    variables: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        items: {
                            enum: variablesEnum,
                        },
                        description: 'Variables of operations `query`, `mutation` and `subscription`.',
                    },
                    arguments: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        items: {
                            enum: argumentsEnum,
                        },
                        description: 'Arguments of fields and directives.',
                    },
                    definitions: {
                        type: 'boolean',
                        description: 'Definitions – `type`, `interface`, `enum`, `scalar`, `input`, `union` and `directive`.',
                        default: false,
                    },
                },
            },
        },
    },
    create(context) {
        var _a, _b, _c, _d, _e;
        const sourceCode = context.getSourceCode();
        function isNodeAndCommentOnSameLine(node, comment) {
            return node.loc.end.line === comment.loc.start.line;
        }
        function getBeforeComments(node) {
            const commentsBefore = sourceCode.getCommentsBefore(node);
            if (commentsBefore.length === 0) {
                return [];
            }
            const tokenBefore = sourceCode.getTokenBefore(node);
            if (tokenBefore) {
                return commentsBefore.filter(comment => !isNodeAndCommentOnSameLine(tokenBefore, comment));
            }
            const filteredComments = [];
            const nodeLine = node.loc.start.line;
            // Break on comment that not attached to node
            for (let i = commentsBefore.length - 1; i >= 0; i -= 1) {
                const comment = commentsBefore[i];
                if (nodeLine - comment.loc.start.line - filteredComments.length > 1) {
                    break;
                }
                filteredComments.unshift(comment);
            }
            return filteredComments;
        }
        function getRangeWithComments(node) {
            if (node.kind === Kind.VARIABLE) {
                node = node.parent;
            }
            const [firstBeforeComment] = getBeforeComments(node);
            const [firstAfterComment] = sourceCode.getCommentsAfter(node);
            const from = firstBeforeComment || node;
            const to = firstAfterComment && isNodeAndCommentOnSameLine(node, firstAfterComment) ? firstAfterComment : node;
            return [from.range[0], to.range[1]];
        }
        function checkNodes(nodes) {
            var _a, _b;
            // Starts from 1, ignore nodes.length <= 1
            for (let i = 1; i < nodes.length; i += 1) {
                const currNode = nodes[i];
                const currName = 'name' in currNode && ((_a = currNode.name) === null || _a === void 0 ? void 0 : _a.value);
                if (!currName) {
                    // we don't move unnamed current nodes
                    continue;
                }
                const prevNode = nodes[i - 1];
                const prevName = 'name' in prevNode && ((_b = prevNode.name) === null || _b === void 0 ? void 0 : _b.value);
                if (prevName) {
                    // Compare with lexicographic order
                    const compareResult = prevName.localeCompare(currName);
                    const shouldSort = compareResult === 1;
                    if (!shouldSort) {
                        const isSameName = compareResult === 0;
                        if (!isSameName || !prevNode.kind.endsWith('Extension') || currNode.kind.endsWith('Extension')) {
                            continue;
                        }
                    }
                }
                context.report({
                    node: currNode.name,
                    messageId: RULE_ID,
                    data: {
                        currName,
                        prevName: prevName ? `\`${prevName}\`` : lowerCase(prevNode.kind),
                    },
                    *fix(fixer) {
                        const prevRange = getRangeWithComments(prevNode);
                        const currRange = getRangeWithComments(currNode);
                        yield fixer.replaceTextRange(prevRange, sourceCode.getText({ range: currRange }));
                        yield fixer.replaceTextRange(currRange, sourceCode.getText({ range: prevRange }));
                    },
                });
            }
        }
        const opts = context.options[0];
        const fields = new Set((_a = opts.fields) !== null && _a !== void 0 ? _a : []);
        const listeners = {};
        const kinds = [
            fields.has(Kind.OBJECT_TYPE_DEFINITION) && [Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION],
            fields.has(Kind.INTERFACE_TYPE_DEFINITION) && [Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION],
            fields.has(Kind.INPUT_OBJECT_TYPE_DEFINITION) && [
                Kind.INPUT_OBJECT_TYPE_DEFINITION,
                Kind.INPUT_OBJECT_TYPE_EXTENSION,
            ],
        ]
            .filter(Boolean)
            .flat();
        const fieldsSelector = kinds.join(',');
        const hasEnumValues = ((_b = opts.values) === null || _b === void 0 ? void 0 : _b[0]) === Kind.ENUM_TYPE_DEFINITION;
        const selectionsSelector = (_c = opts.selections) === null || _c === void 0 ? void 0 : _c.join(',');
        const hasVariables = ((_d = opts.variables) === null || _d === void 0 ? void 0 : _d[0]) === Kind.OPERATION_DEFINITION;
        const argumentsSelector = (_e = opts.arguments) === null || _e === void 0 ? void 0 : _e.join(',');
        if (fieldsSelector) {
            listeners[fieldsSelector] = (node) => {
                checkNodes(node.fields);
            };
        }
        if (hasEnumValues) {
            const enumValuesSelector = [Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION].join(',');
            listeners[enumValuesSelector] = (node) => {
                checkNodes(node.values);
            };
        }
        if (selectionsSelector) {
            listeners[`:matches(${selectionsSelector}) SelectionSet`] = (node) => {
                checkNodes(node.selections.map(selection => 
                // sort by alias is field is renamed
                'alias' in selection && selection.alias ? { name: selection.alias } : selection));
            };
        }
        if (hasVariables) {
            listeners.OperationDefinition = (node) => {
                checkNodes(node.variableDefinitions.map(varDef => varDef.variable));
            };
        }
        if (argumentsSelector) {
            listeners[argumentsSelector] = (node) => {
                checkNodes(node.arguments);
            };
        }
        if (opts.definitions) {
            listeners.Document = node => {
                checkNodes(node.definitions);
            };
        }
        return listeners;
    },
};

const rule$1 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ style: 'inline' }],
                    code: /* GraphQL */ `
            """ Description """
            type someTypeName {
              # ...
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ style: 'inline' }],
                    code: /* GraphQL */ `
            " Description "
            type someTypeName {
              # ...
            }
          `,
                },
            ],
            description: 'Require all comments to follow the same style (either block or inline).',
            category: 'Schema',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/description-style.md',
            recommended: true,
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    style: {
                        enum: ['block', 'inline'],
                        default: 'block',
                    },
                },
            },
        ],
    },
    create(context) {
        const { style = 'block' } = context.options[0] || {};
        const isBlock = style === 'block';
        return {
            [`.description[type=StringValue][block!=${isBlock}]`](node) {
                context.report({
                    loc: isBlock ? node.loc : node.loc.start,
                    message: `Unexpected ${isBlock ? 'inline' : 'block'} description.`,
                    suggest: [
                        {
                            desc: `Change to ${isBlock ? 'block' : 'inline'} style description`,
                            fix(fixer) {
                                const sourceCode = context.getSourceCode();
                                const originalText = sourceCode.getText(node);
                                const newText = isBlock
                                    ? originalText.replace(/(^")|("$)/g, '"""')
                                    : originalText.replace(/(^""")|("""$)/g, '"').replace(/\s+/g, ' ');
                                return fixer.replaceText(node, newText);
                            },
                        },
                    ],
                });
            },
        };
    },
};

const isObjectType = (node) => [Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION].includes(node.type);
const isQueryType = (node) => isObjectType(node) && node.name.value === 'Query';
const isMutationType = (node) => isObjectType(node) && node.name.value === 'Mutation';
const rule$2 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            description: 'Require mutation argument to be always called "input" and input type to be called Mutation name + "Input".\nUsing the same name for all input parameters will make your schemas easier to consume and more predictable. Using the same name as mutation for InputType will make it easier to find mutations that InputType belongs to.',
            category: 'Schema',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/input-name.md',
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ checkInputType: true }],
                    code: /* GraphQL */ `
            type Mutation {
              SetMessage(message: InputMessage): String
            }
          `,
                },
                {
                    title: 'Correct (with checkInputType)',
                    usage: [{ checkInputType: true }],
                    code: /* GraphQL */ `
            type Mutation {
              SetMessage(input: SetMessageInput): String
            }
          `,
                },
                {
                    title: 'Correct (without checkInputType)',
                    usage: [{ checkInputType: false }],
                    code: /* GraphQL */ `
            type Mutation {
              SetMessage(input: AnyInputTypeName): String
            }
          `,
                },
            ],
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    checkInputType: {
                        type: 'boolean',
                        default: false,
                        description: 'Check that the input type name follows the convention <mutationName>Input',
                    },
                    caseSensitiveInputType: {
                        type: 'boolean',
                        default: true,
                        description: 'Allow for case discrepancies in the input type name',
                    },
                    checkQueries: {
                        type: 'boolean',
                        default: false,
                        description: 'Apply the rule to Queries',
                    },
                    checkMutations: {
                        type: 'boolean',
                        default: true,
                        description: 'Apply the rule to Mutations',
                    },
                },
            },
        ],
    },
    create(context) {
        const options = {
            checkInputType: false,
            caseSensitiveInputType: true,
            checkQueries: false,
            checkMutations: true,
            ...context.options[0],
        };
        const shouldCheckType = node => (options.checkMutations && isMutationType(node)) || (options.checkQueries && isQueryType(node));
        const listeners = {
            'FieldDefinition > InputValueDefinition[name.value!=input] > Name'(node) {
                if (shouldCheckType(node.parent.parent.parent)) {
                    const inputName = node.value;
                    context.report({
                        node,
                        message: `Input \`${inputName}\` should be called \`input\`.`,
                        suggest: [
                            {
                                desc: 'Rename to `input`',
                                fix: fixer => fixer.replaceText(node, 'input'),
                            },
                        ],
                    });
                }
            },
        };
        if (options.checkInputType) {
            listeners['FieldDefinition > InputValueDefinition NamedType'] = (node) => {
                const findInputType = item => {
                    let currentNode = item;
                    while (currentNode.type !== Kind.INPUT_VALUE_DEFINITION) {
                        currentNode = currentNode.parent;
                    }
                    return currentNode;
                };
                const inputValueNode = findInputType(node);
                if (shouldCheckType(inputValueNode.parent.parent)) {
                    const mutationName = `${inputValueNode.parent.name.value}Input`;
                    const name = node.name.value;
                    if ((options.caseSensitiveInputType && node.name.value !== mutationName) ||
                        name.toLowerCase() !== mutationName.toLowerCase()) {
                        context.report({
                            node: node.name,
                            message: `Input type \`${name}\` name should be \`${mutationName}\`.`,
                            suggest: [
                                {
                                    desc: `Rename to \`${mutationName}\``,
                                    fix: fixer => fixer.replaceText(node, mutationName),
                                },
                            ],
                        });
                    }
                }
            };
        }
        return listeners;
    },
};

const MATCH_EXTENSION = 'MATCH_EXTENSION';
const MATCH_STYLE = 'MATCH_STYLE';
const ACCEPTED_EXTENSIONS = ['.gql', '.graphql'];
const CASE_STYLES = [
    'camelCase',
    'PascalCase',
    'snake_case',
    'UPPER_CASE',
    'kebab-case',
    'matchDocumentStyle',
];
const schemaOption = {
    oneOf: [{ $ref: '#/definitions/asString' }, { $ref: '#/definitions/asObject' }],
};
const rule$3 = {
    meta: {
        type: 'suggestion',
        docs: {
            category: 'Operations',
            description: 'This rule allows you to enforce that the file name should match the operation name.',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/match-document-filename.md',
            examples: [
                {
                    title: 'Correct',
                    usage: [{ fileExtension: '.gql' }],
                    code: /* GraphQL */ `
            # user.gql
            type User {
              id: ID!
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ query: 'snake_case' }],
                    code: /* GraphQL */ `
            # user_by_id.gql
            query UserById {
              userById(id: 5) {
                id
                name
                fullName
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ fragment: { style: 'kebab-case', suffix: '.fragment' } }],
                    code: /* GraphQL */ `
            # user-fields.fragment.gql
            fragment user_fields on User {
              id
              email
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ mutation: { style: 'PascalCase', suffix: 'Mutation' } }],
                    code: /* GraphQL */ `
            # DeleteUserMutation.gql
            mutation DELETE_USER {
              deleteUser(id: 5)
            }
          `,
                },
                {
                    title: 'Incorrect',
                    usage: [{ fileExtension: '.graphql' }],
                    code: /* GraphQL */ `
            # post.gql
            type Post {
              id: ID!
            }
          `,
                },
                {
                    title: 'Incorrect',
                    usage: [{ query: 'PascalCase' }],
                    code: /* GraphQL */ `
            # user-by-id.gql
            query UserById {
              userById(id: 5) {
                id
                name
                fullName
              }
            }
          `,
                },
            ],
            configOptions: [
                {
                    query: 'kebab-case',
                    mutation: 'kebab-case',
                    subscription: 'kebab-case',
                    fragment: 'kebab-case',
                },
            ],
        },
        messages: {
            [MATCH_EXTENSION]: 'File extension "{{ fileExtension }}" don\'t match extension "{{ expectedFileExtension }}"',
            [MATCH_STYLE]: 'Unexpected filename "{{ filename }}". Rename it to "{{ expectedFilename }}"',
        },
        schema: {
            definitions: {
                asString: {
                    enum: CASE_STYLES,
                    description: `One of: ${CASE_STYLES.map(t => `\`${t}\``).join(', ')}`,
                },
                asObject: {
                    type: 'object',
                    additionalProperties: false,
                    minProperties: 1,
                    properties: {
                        style: { enum: CASE_STYLES },
                        suffix: { type: 'string' },
                    },
                },
            },
            type: 'array',
            minItems: 1,
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                minProperties: 1,
                properties: {
                    fileExtension: { enum: ACCEPTED_EXTENSIONS },
                    query: schemaOption,
                    mutation: schemaOption,
                    subscription: schemaOption,
                    fragment: schemaOption,
                },
            },
        },
    },
    create(context) {
        const options = context.options[0] || {
            fileExtension: null,
        };
        const filePath = context.getFilename();
        const isVirtualFile = !existsSync(filePath);
        if (process.env.NODE_ENV !== 'test' && isVirtualFile) {
            // Skip validation for code files
            return {};
        }
        const fileExtension = extname(filePath);
        const filename = basename(filePath, fileExtension);
        return {
            Document(documentNode) {
                var _a;
                if (options.fileExtension && options.fileExtension !== fileExtension) {
                    context.report({
                        loc: REPORT_ON_FIRST_CHARACTER,
                        messageId: MATCH_EXTENSION,
                        data: {
                            fileExtension,
                            expectedFileExtension: options.fileExtension,
                        },
                    });
                }
                const firstOperation = documentNode.definitions.find(n => n.kind === Kind.OPERATION_DEFINITION);
                const firstFragment = documentNode.definitions.find(n => n.kind === Kind.FRAGMENT_DEFINITION);
                const node = firstOperation || firstFragment;
                if (!node) {
                    return;
                }
                const docName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
                if (!docName) {
                    return;
                }
                const docType = 'operation' in node ? node.operation : 'fragment';
                let option = options[docType];
                if (!option) {
                    // Config not provided
                    return;
                }
                if (typeof option === 'string') {
                    option = { style: option };
                }
                const expectedExtension = options.fileExtension || fileExtension;
                let expectedFilename;
                if (option.style) {
                    expectedFilename = option.style === 'matchDocumentStyle' ? docName : convertCase(option.style, docName);
                }
                else {
                    expectedFilename = filename;
                }
                expectedFilename += (option.suffix || '') + expectedExtension;
                const filenameWithExtension = filename + expectedExtension;
                if (expectedFilename !== filenameWithExtension) {
                    context.report({
                        loc: REPORT_ON_FIRST_CHARACTER,
                        messageId: MATCH_STYLE,
                        data: {
                            expectedFilename,
                            filename: filenameWithExtension,
                        },
                    });
                }
            },
        };
    },
};

const KindToDisplayName = {
    // types
    [Kind.OBJECT_TYPE_DEFINITION]: 'Type',
    [Kind.INTERFACE_TYPE_DEFINITION]: 'Interface',
    [Kind.ENUM_TYPE_DEFINITION]: 'Enumerator',
    [Kind.SCALAR_TYPE_DEFINITION]: 'Scalar',
    [Kind.INPUT_OBJECT_TYPE_DEFINITION]: 'Input type',
    [Kind.UNION_TYPE_DEFINITION]: 'Union',
    // fields
    [Kind.FIELD_DEFINITION]: 'Field',
    [Kind.INPUT_VALUE_DEFINITION]: 'Input property',
    [Kind.ARGUMENT]: 'Argument',
    [Kind.DIRECTIVE_DEFINITION]: 'Directive',
    // rest
    [Kind.ENUM_VALUE_DEFINITION]: 'Enumeration value',
    [Kind.OPERATION_DEFINITION]: 'Operation',
    [Kind.FRAGMENT_DEFINITION]: 'Fragment',
    [Kind.VARIABLE_DEFINITION]: 'Variable',
};
const StyleToRegex = {
    camelCase: /^[a-z][\dA-Za-z]*$/,
    PascalCase: /^[A-Z][\dA-Za-z]*$/,
    snake_case: /^[a-z][\d_a-z]*[\da-z]*$/,
    UPPER_CASE: /^[A-Z][\dA-Z_]*[\dA-Z]*$/,
};
const ALLOWED_KINDS = Object.keys(KindToDisplayName).sort();
const ALLOWED_STYLES = Object.keys(StyleToRegex);
const schemaOption$1 = {
    oneOf: [{ $ref: '#/definitions/asString' }, { $ref: '#/definitions/asObject' }],
};
const rule$4 = {
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require names to follow specified conventions.',
            category: ['Schema', 'Operations'],
            recommended: true,
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/naming-convention.md',
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ types: 'PascalCase', FieldDefinition: 'camelCase' }],
                    code: /* GraphQL */ `
            type user {
              first_name: String!
            }
          `,
                },
                {
                    title: 'Incorrect',
                    usage: [{ FragmentDefinition: { style: 'PascalCase', forbiddenSuffixes: ['Fragment'] } }],
                    code: /* GraphQL */ `
            fragment UserFragment on User {
              # ...
            }
          `,
                },
                {
                    title: 'Incorrect',
                    usage: [{ 'FieldDefinition[parent.name.value=Query]': { forbiddenPrefixes: ['get'] } }],
                    code: /* GraphQL */ `
            type Query {
              getUsers: [User!]!
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ types: 'PascalCase', FieldDefinition: 'camelCase' }],
                    code: /* GraphQL */ `
            type User {
              firstName: String
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ FragmentDefinition: { style: 'PascalCase', forbiddenSuffixes: ['Fragment'] } }],
                    code: /* GraphQL */ `
            fragment UserFields on User {
              # ...
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ 'FieldDefinition[parent.name.value=Query]': { forbiddenPrefixes: ['get'] } }],
                    code: /* GraphQL */ `
            type Query {
              users: [User!]!
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ FieldDefinition: { style: 'camelCase', ignorePattern: '^(EAN13|UPC|UK)' } }],
                    code: /* GraphQL */ `
            type Product {
              EAN13: String
              UPC: String
              UKFlag: String
            }
          `,
                },
            ],
            configOptions: {
                schema: [
                    {
                        types: 'PascalCase',
                        FieldDefinition: 'camelCase',
                        InputValueDefinition: 'camelCase',
                        Argument: 'camelCase',
                        DirectiveDefinition: 'camelCase',
                        EnumValueDefinition: 'UPPER_CASE',
                        'FieldDefinition[parent.name.value=Query]': {
                            forbiddenPrefixes: ['query', 'get'],
                            forbiddenSuffixes: ['Query'],
                        },
                        'FieldDefinition[parent.name.value=Mutation]': {
                            forbiddenPrefixes: ['mutation'],
                            forbiddenSuffixes: ['Mutation'],
                        },
                        'FieldDefinition[parent.name.value=Subscription]': {
                            forbiddenPrefixes: ['subscription'],
                            forbiddenSuffixes: ['Subscription'],
                        },
                    },
                ],
                operations: [
                    {
                        VariableDefinition: 'camelCase',
                        OperationDefinition: {
                            style: 'PascalCase',
                            forbiddenPrefixes: ['Query', 'Mutation', 'Subscription', 'Get'],
                            forbiddenSuffixes: ['Query', 'Mutation', 'Subscription'],
                        },
                        FragmentDefinition: {
                            style: 'PascalCase',
                            forbiddenPrefixes: ['Fragment'],
                            forbiddenSuffixes: ['Fragment'],
                        },
                    },
                ],
            },
        },
        hasSuggestions: true,
        schema: {
            definitions: {
                asString: {
                    enum: ALLOWED_STYLES,
                    description: `One of: ${ALLOWED_STYLES.map(t => `\`${t}\``).join(', ')}`,
                },
                asObject: {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        style: { enum: ALLOWED_STYLES },
                        prefix: { type: 'string' },
                        suffix: { type: 'string' },
                        forbiddenPrefixes: ARRAY_DEFAULT_OPTIONS,
                        forbiddenSuffixes: ARRAY_DEFAULT_OPTIONS,
                        ignorePattern: {
                            type: 'string',
                            description: 'Option to skip validation of some words, e.g. acronyms',
                        },
                    },
                },
            },
            type: 'array',
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                properties: {
                    types: {
                        ...schemaOption$1,
                        description: `Includes:\n\n${TYPES_KINDS.map(kind => `- \`${kind}\``).join('\n')}`,
                    },
                    ...Object.fromEntries(ALLOWED_KINDS.map(kind => [
                        kind,
                        {
                            ...schemaOption$1,
                            description: `Read more about this kind on [spec.graphql.org](https://spec.graphql.org/October2021/#${kind}).`,
                        },
                    ])),
                    allowLeadingUnderscore: {
                        type: 'boolean',
                        default: false,
                    },
                    allowTrailingUnderscore: {
                        type: 'boolean',
                        default: false,
                    },
                },
                patternProperties: {
                    [`^(${ALLOWED_KINDS.join('|')})(.+)?$`]: schemaOption$1,
                },
                description: [
                    "> It's possible to use a [`selector`](https://eslint.org/docs/developer-guide/selectors) that starts with allowed `ASTNode` names which are described below.",
                    '>',
                    '> Paste or drop code into the editor in [ASTExplorer](https://astexplorer.net) and inspect the generated AST to compose your selector.',
                    '>',
                    '> Example: pattern property `FieldDefinition[parent.name.value=Query]` will match only fields for type `Query`.',
                ].join('\n'),
            },
        },
    },
    create(context) {
        const options = context.options[0] || {};
        const { allowLeadingUnderscore, allowTrailingUnderscore, types, ...restOptions } = options;
        function normalisePropertyOption(kind) {
            const style = restOptions[kind] || types;
            return typeof style === 'object' ? style : { style };
        }
        function report(node, message, suggestedName) {
            context.report({
                node,
                message,
                suggest: [
                    {
                        desc: `Rename to \`${suggestedName}\``,
                        fix: fixer => fixer.replaceText(node, suggestedName),
                    },
                ],
            });
        }
        const checkNode = (selector) => (n) => {
            const { name: node } = n.kind === Kind.VARIABLE_DEFINITION ? n.variable : n;
            if (!node) {
                return;
            }
            const { prefix, suffix, forbiddenPrefixes, forbiddenSuffixes, style, ignorePattern } = normalisePropertyOption(selector);
            const nodeType = KindToDisplayName[n.kind] || n.kind;
            const nodeName = node.value;
            const error = getError();
            if (error) {
                const { errorMessage, renameToName } = error;
                const [leadingUnderscores] = nodeName.match(/^_*/);
                const [trailingUnderscores] = nodeName.match(/_*$/);
                const suggestedName = leadingUnderscores + renameToName + trailingUnderscores;
                report(node, `${nodeType} "${nodeName}" should ${errorMessage}`, suggestedName);
            }
            function getError() {
                const name = nodeName.replace(/(^_+)|(_+$)/g, '');
                if (ignorePattern && new RegExp(ignorePattern, 'u').test(name)) {
                    return;
                }
                if (prefix && !name.startsWith(prefix)) {
                    return {
                        errorMessage: `have "${prefix}" prefix`,
                        renameToName: prefix + name,
                    };
                }
                if (suffix && !name.endsWith(suffix)) {
                    return {
                        errorMessage: `have "${suffix}" suffix`,
                        renameToName: name + suffix,
                    };
                }
                const forbiddenPrefix = forbiddenPrefixes === null || forbiddenPrefixes === void 0 ? void 0 : forbiddenPrefixes.find(prefix => name.startsWith(prefix));
                if (forbiddenPrefix) {
                    return {
                        errorMessage: `not have "${forbiddenPrefix}" prefix`,
                        renameToName: name.replace(new RegExp(`^${forbiddenPrefix}`), ''),
                    };
                }
                const forbiddenSuffix = forbiddenSuffixes === null || forbiddenSuffixes === void 0 ? void 0 : forbiddenSuffixes.find(suffix => name.endsWith(suffix));
                if (forbiddenSuffix) {
                    return {
                        errorMessage: `not have "${forbiddenSuffix}" suffix`,
                        renameToName: name.replace(new RegExp(`${forbiddenSuffix}$`), ''),
                    };
                }
                // Style is optional
                if (!style) {
                    return;
                }
                const caseRegex = StyleToRegex[style];
                if (!caseRegex.test(name)) {
                    return {
                        errorMessage: `be in ${style} format`,
                        renameToName: convertCase(style, name),
                    };
                }
            }
        };
        const checkUnderscore = (isLeading) => (node) => {
            const suggestedName = node.value.replace(isLeading ? /^_+/ : /_+$/, '');
            report(node, `${isLeading ? 'Leading' : 'Trailing'} underscores are not allowed`, suggestedName);
        };
        const listeners = {};
        if (!allowLeadingUnderscore) {
            listeners['Name[value=/^_/]:matches([parent.kind!=Field], [parent.kind=Field][parent.alias])'] =
                checkUnderscore(true);
        }
        if (!allowTrailingUnderscore) {
            listeners['Name[value=/_$/]:matches([parent.kind!=Field], [parent.kind=Field][parent.alias])'] =
                checkUnderscore(false);
        }
        const selectors = new Set([types && TYPES_KINDS, Object.keys(restOptions)].flat().filter(Boolean));
        for (const selector of selectors) {
            listeners[selector] = checkNode(selector);
        }
        return listeners;
    },
};

const RULE_ID$1 = 'no-anonymous-operations';
const rule$5 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Operations',
            description: 'Require name for your GraphQL operations. This is useful since most GraphQL client libraries are using the operation name for caching purposes.',
            recommended: true,
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$1}.md`,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            query {
              # ...
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            query user {
              # ...
            }
          `,
                },
            ],
        },
        messages: {
            [RULE_ID$1]: 'Anonymous GraphQL operations are forbidden. Make sure to name your {{ operation }}!',
        },
        schema: [],
    },
    create(context) {
        return {
            'OperationDefinition[name=undefined]'(node) {
                const [firstSelection] = node.selectionSet.selections;
                const suggestedName = firstSelection.kind === Kind.FIELD ? (firstSelection.alias || firstSelection.name).value : node.operation;
                context.report({
                    loc: getLocation(node.loc.start, node.operation),
                    messageId: RULE_ID$1,
                    data: {
                        operation: node.operation,
                    },
                    suggest: [
                        {
                            desc: `Rename to \`${suggestedName}\``,
                            fix(fixer) {
                                const sourceCode = context.getSourceCode();
                                const hasQueryKeyword = sourceCode.getText({ range: [node.range[0], node.range[0] + 1] }) !== '{';
                                return fixer.insertTextAfterRange([node.range[0], node.range[0] + (hasQueryKeyword ? node.operation.length : 0)], `${hasQueryKeyword ? '' : 'query'} ${suggestedName}${hasQueryKeyword ? '' : ' '}`);
                            },
                        },
                    ],
                });
            },
        };
    },
};

const rule$6 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/no-case-insensitive-enum-values-duplicates.md',
            category: 'Schema',
            recommended: true,
            description: 'Disallow case-insensitive enum values duplicates.',
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            enum MyEnum {
              Value
              VALUE
              ValuE
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            enum MyEnum {
              Value1
              Value2
              Value3
            }
          `,
                },
            ],
        },
        schema: [],
    },
    create(context) {
        const selector = [Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION].join(',');
        return {
            [selector](node) {
                const duplicates = node.values.filter((item, index, array) => array.findIndex(v => v.name.value.toLowerCase() === item.name.value.toLowerCase()) !== index);
                for (const duplicate of duplicates) {
                    const enumName = duplicate.name.value;
                    context.report({
                        node: duplicate.name,
                        message: `Case-insensitive enum values duplicates are not allowed! Found: \`${enumName}\`.`,
                        suggest: [
                            {
                                desc: `Remove \`${enumName}\` enum value`,
                                fix: fixer => fixer.remove(duplicate),
                            },
                        ],
                    });
                }
            },
        };
    },
};

const RULE_ID$2 = 'no-deprecated';
const rule$7 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Operations',
            description: 'Enforce that deprecated fields or enum values are not in use by operations.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$2}.md`,
            requiresSchema: true,
            examples: [
                {
                    title: 'Incorrect (field)',
                    code: /* GraphQL */ `
            # In your schema
            type User {
              id: ID!
              name: String! @deprecated(reason: "old field, please use fullName instead")
              fullName: String!
            }

            # Query
            query user {
              user {
                name # This is deprecated, so you'll get an error
              }
            }
          `,
                },
                {
                    title: 'Incorrect (enum value)',
                    code: /* GraphQL */ `
            # In your schema
            type Mutation {
              changeSomething(type: SomeType): Boolean!
            }

            enum SomeType {
              NEW
              OLD @deprecated(reason: "old field, please use NEW instead")
            }

            # Mutation
            mutation {
              changeSomething(
                type: OLD # This is deprecated, so you'll get an error
              ) {
                ...
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            # In your schema
            type User {
              id: ID!
              name: String! @deprecated(reason: "old field, please use fullName instead")
              fullName: String!
            }

            # Query
            query user {
              user {
                id
                fullName
              }
            }
          `,
                },
            ],
            recommended: true,
        },
        messages: {
            [RULE_ID$2]: 'This {{ type }} is marked as deprecated in your GraphQL schema (reason: {{ reason }})',
        },
        schema: [],
    },
    create(context) {
        requireGraphQLSchemaFromContext(RULE_ID$2, context);
        function report(node, reason) {
            const nodeName = node.kind === Kind.ENUM ? node.value : node.name.value;
            const nodeType = node.kind === Kind.ENUM ? 'enum value' : 'field';
            context.report({
                node,
                messageId: RULE_ID$2,
                data: {
                    type: nodeType,
                    reason,
                },
                suggest: [
                    {
                        desc: `Remove \`${nodeName}\` ${nodeType}`,
                        fix: fixer => fixer.remove(node),
                    },
                ],
            });
        }
        return {
            EnumValue(node) {
                var _a;
                const typeInfo = node.typeInfo();
                const reason = (_a = typeInfo.enumValue) === null || _a === void 0 ? void 0 : _a.deprecationReason;
                if (reason) {
                    report(node, reason);
                }
            },
            Field(node) {
                var _a;
                const typeInfo = node.typeInfo();
                const reason = (_a = typeInfo.fieldDef) === null || _a === void 0 ? void 0 : _a.deprecationReason;
                if (reason) {
                    report(node, reason);
                }
            },
        };
    },
};

const RULE_ID$3 = 'no-duplicate-fields';
const rule$8 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            description: 'Checks for duplicate fields in selection set, variables in operation definition, or in arguments set of a field.',
            category: 'Operations',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$3}.md`,
            recommended: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            query {
              user {
                name
                email
                name # duplicate field
              }
            }
          `,
                },
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            query {
              users(
                first: 100
                skip: 50
                after: "cji629tngfgou0b73kt7vi5jo"
                first: 100 # duplicate argument
              ) {
                id
              }
            }
          `,
                },
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            query (
              $first: Int!
              $first: Int! # duplicate variable
            ) {
              users(first: $first, skip: 50) {
                id
              }
            }
          `,
                },
            ],
        },
        messages: {
            [RULE_ID$3]: '{{ type }} `{{ fieldName }}` defined multiple times.',
        },
        schema: [],
    },
    create(context) {
        function checkNode(usedFields, node) {
            const fieldName = node.value;
            if (usedFields.has(fieldName)) {
                const { parent } = node;
                context.report({
                    node,
                    messageId: RULE_ID$3,
                    data: {
                        type: parent.type,
                        fieldName,
                    },
                    suggest: [
                        {
                            desc: `Remove \`${fieldName}\` ${parent.type.toLowerCase()}`,
                            fix(fixer) {
                                return fixer.remove((parent.type === Kind.VARIABLE ? parent.parent : parent));
                            },
                        },
                    ],
                });
            }
            else {
                usedFields.add(fieldName);
            }
        }
        return {
            OperationDefinition(node) {
                const set = new Set();
                for (const varDef of node.variableDefinitions) {
                    checkNode(set, varDef.variable.name);
                }
            },
            Field(node) {
                const set = new Set();
                for (const arg of node.arguments) {
                    checkNode(set, arg.name);
                }
            },
            SelectionSet(node) {
                const set = new Set();
                for (const selection of node.selections) {
                    if (selection.kind === Kind.FIELD) {
                        checkNode(set, selection.alias || selection.name);
                    }
                }
            },
        };
    },
};

const HASHTAG_COMMENT = 'HASHTAG_COMMENT';
const rule$9 = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        schema: [],
        messages: {
            [HASHTAG_COMMENT]: 'Using hashtag `#` for adding GraphQL descriptions is not allowed. Prefer using `"""` for multiline, or `"` for a single line description.',
        },
        docs: {
            description: 'Requires to use `"""` or `"` for adding a GraphQL description instead of `#`.\nAllows to use hashtag for comments, as long as it\'s not attached to an AST definition.',
            category: 'Schema',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/no-hashtag-description.md',
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            # Represents a user
            type User {
              id: ID!
              name: String
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            " Represents a user "
            type User {
              id: ID!
              name: String
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            # This file defines the basic User type.
            # This comment is valid because it's not attached specifically to an AST object.

            " Represents a user "
            type User {
              id: ID! # This one is also valid, since it comes after the AST object
              name: String
            }
          `,
                },
            ],
            recommended: true,
        },
    },
    create(context) {
        const selector = 'Document[definitions.0.kind!=/^(OperationDefinition|FragmentDefinition)$/]';
        return {
            [selector](node) {
                const rawNode = node.rawNode();
                let token = rawNode.loc.startToken;
                while (token) {
                    const { kind, prev, next, value, line, column } = token;
                    if (kind === TokenKind.COMMENT && prev && next) {
                        const isEslintComment = value.trimStart().startsWith('eslint');
                        const linesAfter = next.line - line;
                        if (!isEslintComment && line !== prev.line && next.kind === TokenKind.NAME && linesAfter < 2) {
                            context.report({
                                messageId: HASHTAG_COMMENT,
                                loc: {
                                    line,
                                    column: column - 1,
                                },
                                suggest: ['"""', '"'].map(descriptionSyntax => ({
                                    desc: `Replace with \`${descriptionSyntax}\` description syntax`,
                                    fix: fixer => fixer.replaceTextRange([token.start, token.end], [descriptionSyntax, value.trim(), descriptionSyntax].join('')),
                                })),
                            });
                        }
                    }
                    token = next;
                }
            },
        };
    },
};

const ROOT_TYPES = ['mutation', 'subscription'];
const rule$a = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Schema',
            description: 'Disallow using root types `mutation` and/or `subscription`.',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/no-root-type.md',
            requiresSchema: true,
            isDisabledForAllConfig: true,
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ disallow: ['mutation', 'subscription'] }],
                    code: /* GraphQL */ `
            type Mutation {
              createUser(input: CreateUserInput!): User!
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ disallow: ['mutation', 'subscription'] }],
                    code: /* GraphQL */ `
            type Query {
              users: [User!]!
            }
          `,
                },
            ],
        },
        schema: {
            type: 'array',
            minItems: 1,
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                required: ['disallow'],
                properties: {
                    disallow: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        items: {
                            enum: ROOT_TYPES,
                        },
                    },
                },
            },
        },
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext('no-root-type', context);
        const disallow = new Set(context.options[0].disallow);
        const rootTypeNames = [
            disallow.has('mutation') && schema.getMutationType(),
            disallow.has('subscription') && schema.getSubscriptionType(),
        ]
            .filter(Boolean)
            .map(type => type.name)
            .join('|');
        if (!rootTypeNames) {
            return {};
        }
        const selector = `:matches(ObjectTypeDefinition, ObjectTypeExtension) > .name[value=/^(${rootTypeNames})$/]`;
        return {
            [selector](node) {
                const typeName = node.value;
                context.report({
                    node,
                    message: `Root type \`${typeName}\` is forbidden.`,
                    suggest: [
                        {
                            desc: `Remove \`${typeName}\` type`,
                            fix: fixer => fixer.remove(node.parent),
                        },
                    ],
                });
            },
        };
    },
};

const RULE_ID$4 = 'no-scalar-result-type-on-mutation';
const rule$b = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Schema',
            description: 'Avoid scalar result type on mutation type to make sure to return a valid state.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$4}.md`,
            requiresSchema: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type Mutation {
              createUser: Boolean
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type Mutation {
              createUser: User!
            }
          `,
                },
            ],
        },
        schema: [],
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$4, context);
        const mutationType = schema.getMutationType();
        if (!mutationType) {
            return {};
        }
        const selector = [
            `:matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value=${mutationType.name}]`,
            '> FieldDefinition > .gqlType Name',
        ].join(' ');
        return {
            [selector](node) {
                const typeName = node.value;
                const graphQLType = schema.getType(typeName);
                if (isScalarType(graphQLType)) {
                    context.report({
                        node,
                        message: `Unexpected scalar result type \`${typeName}\`.`,
                        suggest: [
                            {
                                desc: `Remove \`${typeName}\``,
                                fix: fixer => fixer.remove(node),
                            },
                        ],
                    });
                }
            },
        };
    },
};

const NO_TYPENAME_PREFIX = 'NO_TYPENAME_PREFIX';
const rule$c = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Schema',
            description: 'Enforces users to avoid using the type name in a field name while defining your schema.',
            recommended: true,
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/no-typename-prefix.md',
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User {
              userId: ID!
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type User {
              id: ID!
            }
          `,
                },
            ],
        },
        messages: {
            [NO_TYPENAME_PREFIX]: 'Field "{{ fieldName }}" starts with the name of the parent type "{{ typeName }}"',
        },
        schema: [],
    },
    create(context) {
        return {
            'ObjectTypeDefinition, ObjectTypeExtension, InterfaceTypeDefinition, InterfaceTypeExtension'(node) {
                const typeName = node.name.value;
                const lowerTypeName = typeName.toLowerCase();
                for (const field of node.fields) {
                    const fieldName = field.name.value;
                    if (fieldName.toLowerCase().startsWith(lowerTypeName)) {
                        context.report({
                            data: {
                                fieldName,
                                typeName,
                            },
                            messageId: NO_TYPENAME_PREFIX,
                            node: field.name,
                            suggest: [
                                {
                                    desc: `Remove \`${fieldName.slice(0, typeName.length)}\` prefix`,
                                    fix: fixer => fixer.replaceText(field.name, fieldName.replace(new RegExp(`^${typeName}`, 'i'), '')),
                                },
                            ],
                        });
                    }
                }
            },
        };
    },
};

const RULE_ID$5 = 'no-unreachable-types';
const KINDS = [
    Kind.DIRECTIVE_DEFINITION,
    Kind.OBJECT_TYPE_DEFINITION,
    Kind.OBJECT_TYPE_EXTENSION,
    Kind.INTERFACE_TYPE_DEFINITION,
    Kind.INTERFACE_TYPE_EXTENSION,
    Kind.SCALAR_TYPE_DEFINITION,
    Kind.SCALAR_TYPE_EXTENSION,
    Kind.INPUT_OBJECT_TYPE_DEFINITION,
    Kind.INPUT_OBJECT_TYPE_EXTENSION,
    Kind.UNION_TYPE_DEFINITION,
    Kind.UNION_TYPE_EXTENSION,
    Kind.ENUM_TYPE_DEFINITION,
    Kind.ENUM_TYPE_EXTENSION,
];
let reachableTypesCache;
function getReachableTypes(schema) {
    // We don't want cache reachableTypes on test environment
    // Otherwise reachableTypes will be same for all tests
    if (process.env.NODE_ENV !== 'test' && reachableTypesCache) {
        return reachableTypesCache;
    }
    const reachableTypes = new Set();
    const collect = (node) => {
        const typeName = getTypeName(node);
        if (reachableTypes.has(typeName)) {
            return;
        }
        reachableTypes.add(typeName);
        const type = schema.getType(typeName) || schema.getDirective(typeName);
        if (isInterfaceType(type)) {
            const { objects, interfaces } = schema.getImplementations(type);
            for (const { astNode } of [...objects, ...interfaces]) {
                visit(astNode, visitor);
            }
        }
        else if (type.astNode) {
            // astNode can be undefined for ID, String, Boolean
            visit(type.astNode, visitor);
        }
    };
    const visitor = {
        InterfaceTypeDefinition: collect,
        ObjectTypeDefinition: collect,
        InputValueDefinition: collect,
        UnionTypeDefinition: collect,
        FieldDefinition: collect,
        Directive: collect,
        NamedType: collect,
    };
    for (const type of [
        schema,
        schema.getQueryType(),
        schema.getMutationType(),
        schema.getSubscriptionType(),
    ]) {
        // if schema don't have Query type, schema.astNode will be undefined
        if (type === null || type === void 0 ? void 0 : type.astNode) {
            visit(type.astNode, visitor);
        }
    }
    reachableTypesCache = reachableTypes;
    return reachableTypesCache;
}
const rule$d = {
    meta: {
        messages: {
            [RULE_ID$5]: '{{ type }} `{{ typeName }}` is unreachable.',
        },
        docs: {
            description: 'Requires all types to be reachable at some level by root level fields.',
            category: 'Schema',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$5}.md`,
            requiresSchema: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: String
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: User
            }
          `,
                },
            ],
            recommended: true,
        },
        type: 'suggestion',
        schema: [],
        hasSuggestions: true,
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$5, context);
        const reachableTypes = getReachableTypes(schema);
        return {
            [`:matches(${KINDS}) > .name`](node) {
                const typeName = node.value;
                if (!reachableTypes.has(typeName)) {
                    const type = lowerCase(node.parent.kind.replace(/(Extension|Definition)$/, ''));
                    context.report({
                        node,
                        messageId: RULE_ID$5,
                        data: {
                            type: type[0].toUpperCase() + type.slice(1),
                            typeName,
                        },
                        suggest: [
                            {
                                desc: `Remove \`${typeName}\``,
                                fix: fixer => fixer.remove(node.parent),
                            },
                        ],
                    });
                }
            },
        };
    },
};

const RULE_ID$6 = 'no-unused-fields';
let usedFieldsCache;
function getUsedFields(schema, operations) {
    // We don't want cache usedFields on test environment
    // Otherwise usedFields will be same for all tests
    if (process.env.NODE_ENV !== 'test' && usedFieldsCache) {
        return usedFieldsCache;
    }
    const usedFields = Object.create(null);
    const typeInfo = new TypeInfo(schema);
    const visitor = visitWithTypeInfo(typeInfo, {
        Field(node) {
            var _a;
            const fieldDef = typeInfo.getFieldDef();
            if (!fieldDef) {
                // skip visiting this node if field is not defined in schema
                return false;
            }
            const parentTypeName = typeInfo.getParentType().name;
            const fieldName = node.name.value;
            (_a = usedFields[parentTypeName]) !== null && _a !== void 0 ? _a : (usedFields[parentTypeName] = new Set());
            usedFields[parentTypeName].add(fieldName);
        },
    });
    const allDocuments = [...operations.getOperations(), ...operations.getFragments()];
    for (const { document } of allDocuments) {
        visit(document, visitor);
    }
    usedFieldsCache = usedFields;
    return usedFieldsCache;
}
const rule$e = {
    meta: {
        messages: {
            [RULE_ID$6]: 'Field "{{fieldName}}" is unused',
        },
        docs: {
            description: 'Requires all fields to be used at some level by siblings operations.',
            category: 'Schema',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$6}.md`,
            requiresSiblings: true,
            requiresSchema: true,
            isDisabledForAllConfig: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User {
              id: ID!
              name: String
              someUnusedField: String
            }

            type Query {
              me: User
            }

            query {
              me {
                id
                name
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: User
            }

            query {
              me {
                id
                name
              }
            }
          `,
                },
            ],
        },
        type: 'suggestion',
        schema: [],
        hasSuggestions: true,
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$6, context);
        const siblingsOperations = requireSiblingsOperations(RULE_ID$6, context);
        const usedFields = getUsedFields(schema, siblingsOperations);
        return {
            FieldDefinition(node) {
                var _a;
                const fieldName = node.name.value;
                const parentTypeName = node.parent.name.value;
                const isUsed = (_a = usedFields[parentTypeName]) === null || _a === void 0 ? void 0 : _a.has(fieldName);
                if (isUsed) {
                    return;
                }
                context.report({
                    node: node.name,
                    messageId: RULE_ID$6,
                    data: { fieldName },
                    suggest: [
                        {
                            desc: `Remove \`${fieldName}\` field`,
                            fix(fixer) {
                                const sourceCode = context.getSourceCode();
                                const tokenBefore = sourceCode.getTokenBefore(node);
                                const tokenAfter = sourceCode.getTokenAfter(node);
                                const isEmptyType = tokenBefore.type === '{' && tokenAfter.type === '}';
                                return fixer.remove((isEmptyType ? node.parent : node));
                            },
                        },
                    ],
                });
            },
        };
    },
};

const RULE_ID$7 = 'relay-arguments';
const MISSING_ARGUMENTS = 'MISSING_ARGUMENTS';
const rule$f = {
    meta: {
        type: 'problem',
        docs: {
            category: 'Schema',
            description: [
                'Set of rules to follow Relay specification for Arguments.',
                '',
                '- A field that returns a Connection type must include forward pagination arguments (`first` and `after`), backward pagination arguments (`last` and `before`), or both',
                '',
                'Forward pagination arguments',
                '',
                '- `first` takes a non-negative integer',
                '- `after` takes the Cursor type',
                '',
                'Backward pagination arguments',
                '',
                '- `last` takes a non-negative integer',
                '- `before` takes the Cursor type',
            ].join('\n'),
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$7}.md`,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User {
              posts: PostConnection
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type User {
              posts(after: String, first: Int, before: String, last: Int): PostConnection
            }
          `,
                },
            ],
            isDisabledForAllConfig: true,
        },
        messages: {
            [MISSING_ARGUMENTS]: 'A field that returns a Connection type must include forward pagination arguments (`first` and `after`), backward pagination arguments (`last` and `before`), or both.',
        },
        schema: {
            type: 'array',
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                minProperties: 1,
                properties: {
                    includeBoth: {
                        type: 'boolean',
                        default: true,
                        description: 'Enforce including both forward and backward pagination arguments',
                    },
                },
            },
        },
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$7, context);
        const { includeBoth = true } = context.options[0] || {};
        return {
            'FieldDefinition > .gqlType Name[value=/Connection$/]'(node) {
                let fieldNode = node.parent;
                while (fieldNode.kind !== Kind.FIELD_DEFINITION) {
                    fieldNode = fieldNode.parent;
                }
                const args = Object.fromEntries(fieldNode.arguments.map(argument => [argument.name.value, argument]));
                const hasForwardPagination = Boolean(args.first && args.after);
                const hasBackwardPagination = Boolean(args.last && args.before);
                if (!hasForwardPagination && !hasBackwardPagination) {
                    context.report({
                        node: fieldNode.name,
                        messageId: MISSING_ARGUMENTS,
                    });
                    return;
                }
                function checkField(typeName, argumentName) {
                    const argument = args[argumentName];
                    const hasArgument = Boolean(argument);
                    let type = argument;
                    if (hasArgument && type.gqlType.kind === Kind.NON_NULL_TYPE) {
                        type = type.gqlType;
                    }
                    const isAllowedNonNullType = hasArgument &&
                        type.gqlType.kind === Kind.NAMED_TYPE &&
                        (type.gqlType.name.value === typeName ||
                            (typeName === 'String' && isScalarType(schema.getType(type.gqlType.name.value))));
                    if (!isAllowedNonNullType) {
                        const returnType = typeName === 'String' ? 'String or Scalar' : typeName;
                        context.report({
                            node: (argument || fieldNode).name,
                            message: hasArgument
                                ? `Argument \`${argumentName}\` must return ${returnType}.`
                                : `Field \`${fieldNode.name.value}\` must contain an argument \`${argumentName}\`, that return ${returnType}.`,
                        });
                    }
                }
                if (includeBoth || args.first || args.after) {
                    checkField('Int', 'first');
                    checkField('String', 'after');
                }
                if (includeBoth || args.last || args.before) {
                    checkField('Int', 'last');
                    checkField('String', 'before');
                }
            },
        };
    },
};

const MUST_BE_OBJECT_TYPE = 'MUST_BE_OBJECT_TYPE';
const MUST_CONTAIN_FIELD_EDGES = 'MUST_CONTAIN_FIELD_EDGES';
const MUST_CONTAIN_FIELD_PAGE_INFO = 'MUST_CONTAIN_FIELD_PAGE_INFO';
const MUST_HAVE_CONNECTION_SUFFIX = 'MUST_HAVE_CONNECTION_SUFFIX';
const EDGES_FIELD_MUST_RETURN_LIST_TYPE = 'EDGES_FIELD_MUST_RETURN_LIST_TYPE';
const PAGE_INFO_FIELD_MUST_RETURN_NON_NULL_TYPE = 'PAGE_INFO_FIELD_MUST_RETURN_NON_NULL_TYPE';
const NON_OBJECT_TYPES = [
    Kind.SCALAR_TYPE_DEFINITION,
    Kind.UNION_TYPE_DEFINITION,
    Kind.UNION_TYPE_EXTENSION,
    Kind.INPUT_OBJECT_TYPE_DEFINITION,
    Kind.INPUT_OBJECT_TYPE_EXTENSION,
    Kind.ENUM_TYPE_DEFINITION,
    Kind.ENUM_TYPE_EXTENSION,
    Kind.INTERFACE_TYPE_DEFINITION,
    Kind.INTERFACE_TYPE_EXTENSION,
];
const notConnectionTypesSelector = `:matches(${NON_OBJECT_TYPES})[name.value=/Connection$/] > .name`;
const hasEdgesField = (node) => node.fields.some(field => field.name.value === 'edges');
const hasPageInfoField = (node) => node.fields.some(field => field.name.value === 'pageInfo');
const rule$g = {
    meta: {
        type: 'problem',
        docs: {
            category: 'Schema',
            description: [
                'Set of rules to follow Relay specification for Connection types.',
                '',
                '- Any type whose name ends in "Connection" is considered by spec to be a `Connection type`',
                '- Connection type must be an Object type',
                '- Connection type must contain a field `edges` that return a list type that wraps an edge type',
                '- Connection type must contain a field `pageInfo` that return a non-null `PageInfo` Object type',
            ].join('\n'),
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/relay-connection-types.md',
            isDisabledForAllConfig: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type UserPayload { # should be an Object type with \`Connection\` suffix
              edges: UserEdge! # should return a list type
              pageInfo: PageInfo # should return a non-null \`PageInfo\` Object type
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type UserConnection {
              edges: [UserEdge]
              pageInfo: PageInfo!
            }
          `,
                },
            ],
        },
        messages: {
            // Connection types
            [MUST_BE_OBJECT_TYPE]: 'Connection type must be an Object type.',
            [MUST_HAVE_CONNECTION_SUFFIX]: 'Connection type must have `Connection` suffix.',
            [MUST_CONTAIN_FIELD_EDGES]: 'Connection type must contain a field `edges` that return a list type.',
            [MUST_CONTAIN_FIELD_PAGE_INFO]: 'Connection type must contain a field `pageInfo` that return a non-null `PageInfo` Object type.',
            [EDGES_FIELD_MUST_RETURN_LIST_TYPE]: '`edges` field must return a list type.',
            [PAGE_INFO_FIELD_MUST_RETURN_NON_NULL_TYPE]: '`pageInfo` field must return a non-null `PageInfo` Object type.',
        },
        schema: [],
    },
    create(context) {
        return {
            [notConnectionTypesSelector](node) {
                context.report({ node, messageId: MUST_BE_OBJECT_TYPE });
            },
            ':matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value!=/Connection$/]'(node) {
                if (hasEdgesField(node) && hasPageInfoField(node)) {
                    context.report({ node: node.name, messageId: MUST_HAVE_CONNECTION_SUFFIX });
                }
            },
            ':matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value=/Connection$/]'(node) {
                if (!hasEdgesField(node)) {
                    context.report({ node: node.name, messageId: MUST_CONTAIN_FIELD_EDGES });
                }
                if (!hasPageInfoField(node)) {
                    context.report({ node: node.name, messageId: MUST_CONTAIN_FIELD_PAGE_INFO });
                }
            },
            ':matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value=/Connection$/] > FieldDefinition[name.value=edges] > .gqlType'(node) {
                const isListType = node.kind === Kind.LIST_TYPE || (node.kind === Kind.NON_NULL_TYPE && node.gqlType.kind === Kind.LIST_TYPE);
                if (!isListType) {
                    context.report({ node, messageId: EDGES_FIELD_MUST_RETURN_LIST_TYPE });
                }
            },
            ':matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value=/Connection$/] > FieldDefinition[name.value=pageInfo] > .gqlType'(node) {
                const isNonNullPageInfoType = node.kind === Kind.NON_NULL_TYPE &&
                    node.gqlType.kind === Kind.NAMED_TYPE &&
                    node.gqlType.name.value === 'PageInfo';
                if (!isNonNullPageInfoType) {
                    context.report({ node, messageId: PAGE_INFO_FIELD_MUST_RETURN_NON_NULL_TYPE });
                }
            },
        };
    },
};

const RULE_ID$8 = 'relay-edge-types';
const MESSAGE_MUST_BE_OBJECT_TYPE = 'MESSAGE_MUST_BE_OBJECT_TYPE';
const MESSAGE_MISSING_EDGE_SUFFIX = 'MESSAGE_MISSING_EDGE_SUFFIX';
const MESSAGE_LIST_TYPE_ONLY_EDGE_TYPE = 'MESSAGE_LIST_TYPE_ONLY_EDGE_TYPE';
const MESSAGE_SHOULD_IMPLEMENTS_NODE = 'MESSAGE_SHOULD_IMPLEMENTS_NODE';
let edgeTypesCache;
function getEdgeTypes(schema) {
    // We don't want cache edgeTypes on test environment
    // Otherwise edgeTypes will be same for all tests
    if (process.env.NODE_ENV !== 'test' && edgeTypesCache) {
        return edgeTypesCache;
    }
    const edgeTypes = new Set();
    const visitor = {
        ObjectTypeDefinition(node) {
            const typeName = node.name.value;
            const hasConnectionSuffix = typeName.endsWith('Connection');
            if (!hasConnectionSuffix) {
                return;
            }
            const edges = node.fields.find(field => field.name.value === 'edges');
            if (edges) {
                const edgesTypeName = getTypeName(edges);
                const edgesType = schema.getType(edgesTypeName);
                if (isObjectType$1(edgesType)) {
                    edgeTypes.add(edgesTypeName);
                }
            }
        },
    };
    const astNode = getDocumentNodeFromSchema(schema); // Transforms the schema into ASTNode
    visit(astNode, visitor);
    edgeTypesCache = edgeTypes;
    return edgeTypesCache;
}
const rule$h = {
    meta: {
        type: 'problem',
        docs: {
            category: 'Schema',
            description: [
                'Set of rules to follow Relay specification for Edge types.',
                '',
                "- A type that is returned in list form by a connection type's `edges` field is considered by this spec to be an Edge type",
                '- Edge type must be an Object type',
                '- Edge type must contain a field `node` that return either Scalar, Enum, Object, Interface, Union, or a non-null wrapper around one of those types. Notably, this field cannot return a list',
                '- Edge type must contain a field `cursor` that return either String, Scalar, or a non-null wrapper around one of those types',
                '- Edge type name must end in "Edge" _(optional)_',
                "- Edge type's field `node` must implement `Node` interface _(optional)_",
                '- A list type should only wrap an edge type _(optional)_',
            ].join('\n'),
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$8}.md`,
            isDisabledForAllConfig: true,
            requiresSchema: true,
            examples: [
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type UserConnection {
              edges: [UserEdge]
              pageInfo: PageInfo!
            }
          `,
                },
            ],
        },
        messages: {
            [MESSAGE_MUST_BE_OBJECT_TYPE]: 'Edge type must be an Object type.',
            [MESSAGE_MISSING_EDGE_SUFFIX]: 'Edge type must have "Edge" suffix.',
            [MESSAGE_LIST_TYPE_ONLY_EDGE_TYPE]: 'A list type should only wrap an edge type.',
            [MESSAGE_SHOULD_IMPLEMENTS_NODE]: "Edge type's field `node` must implement `Node` interface.",
        },
        schema: {
            type: 'array',
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                minProperties: 1,
                properties: {
                    withEdgeSuffix: {
                        type: 'boolean',
                        default: true,
                        description: 'Edge type name must end in "Edge".',
                    },
                    shouldImplementNode: {
                        type: 'boolean',
                        default: true,
                        description: "Edge type's field `node` must implement `Node` interface.",
                    },
                    listTypeCanWrapOnlyEdgeType: {
                        type: 'boolean',
                        default: true,
                        description: 'A list type should only wrap an edge type.',
                    },
                },
            },
        },
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$8, context);
        const edgeTypes = getEdgeTypes(schema);
        const options = {
            withEdgeSuffix: true,
            shouldImplementNode: true,
            listTypeCanWrapOnlyEdgeType: true,
            ...context.options[0],
        };
        const isNamedOrNonNullNamed = (node) => node.kind === Kind.NAMED_TYPE || (node.kind === Kind.NON_NULL_TYPE && node.gqlType.kind === Kind.NAMED_TYPE);
        const checkNodeField = (node) => {
            const nodeField = node.fields.find(field => field.name.value === 'node');
            const message = 'return either a Scalar, Enum, Object, Interface, Union, or a non-null wrapper around one of those types.';
            if (!nodeField) {
                context.report({
                    node: node.name,
                    message: `Edge type must contain a field \`node\` that ${message}`,
                });
            }
            else if (!isNamedOrNonNullNamed(nodeField.gqlType)) {
                context.report({ node: nodeField.name, message: `Field \`node\` must ${message}` });
            }
            else if (options.shouldImplementNode) {
                const nodeReturnTypeName = getTypeName(nodeField.gqlType.rawNode());
                const type = schema.getType(nodeReturnTypeName);
                if (!isObjectType$1(type)) {
                    return;
                }
                const implementsNode = type.astNode.interfaces.some(n => n.name.value === 'Node');
                if (!implementsNode) {
                    context.report({ node: node.name, messageId: MESSAGE_SHOULD_IMPLEMENTS_NODE });
                }
            }
        };
        const checkCursorField = (node) => {
            const cursorField = node.fields.find(field => field.name.value === 'cursor');
            const message = 'return either a String, Scalar, or a non-null wrapper wrapper around one of those types.';
            if (!cursorField) {
                context.report({
                    node: node.name,
                    message: `Edge type must contain a field \`cursor\` that ${message}`,
                });
                return;
            }
            const typeName = getTypeName(cursorField.rawNode());
            if (!isNamedOrNonNullNamed(cursorField.gqlType) ||
                (typeName !== 'String' && !isScalarType(schema.getType(typeName)))) {
                context.report({ node: cursorField.name, message: `Field \`cursor\` must ${message}` });
            }
        };
        const listeners = {
            ':matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value=/Connection$/] > FieldDefinition[name.value=edges] > .gqlType Name'(node) {
                const type = schema.getType(node.value);
                if (!isObjectType$1(type)) {
                    context.report({ node, messageId: MESSAGE_MUST_BE_OBJECT_TYPE });
                }
            },
            ':matches(ObjectTypeDefinition, ObjectTypeExtension)'(node) {
                const typeName = node.name.value;
                if (edgeTypes.has(typeName)) {
                    checkNodeField(node);
                    checkCursorField(node);
                    if (options.withEdgeSuffix && !typeName.endsWith('Edge')) {
                        context.report({ node: node.name, messageId: MESSAGE_MISSING_EDGE_SUFFIX });
                    }
                }
            },
        };
        if (options.listTypeCanWrapOnlyEdgeType) {
            listeners['FieldDefinition > .gqlType'] = (node) => {
                if (node.kind === Kind.LIST_TYPE ||
                    (node.kind === Kind.NON_NULL_TYPE && node.gqlType.kind === Kind.LIST_TYPE)) {
                    const typeName = getTypeName(node.rawNode());
                    if (!edgeTypes.has(typeName)) {
                        context.report({ node, messageId: MESSAGE_LIST_TYPE_ONLY_EDGE_TYPE });
                    }
                }
            };
        }
        return listeners;
    },
};

const RULE_ID$9 = 'relay-page-info';
const MESSAGE_MUST_EXIST = 'MESSAGE_MUST_EXIST';
const MESSAGE_MUST_BE_OBJECT_TYPE$1 = 'MESSAGE_MUST_BE_OBJECT_TYPE';
const notPageInfoTypesSelector = `:matches(${NON_OBJECT_TYPES})[name.value=PageInfo] > .name`;
let hasPageInfoChecked = false;
const rule$i = {
    meta: {
        type: 'problem',
        docs: {
            category: 'Schema',
            description: [
                'Set of rules to follow Relay specification for `PageInfo` object.',
                '',
                '- `PageInfo` must be an Object type',
                '- `PageInfo` must contain fields `hasPreviousPage` and `hasNextPage`, that return non-null Boolean',
                '- `PageInfo` must contain fields `startCursor` and `endCursor`, that return either String or Scalar, which can be null if there are no results',
            ].join('\n'),
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$9}.md`,
            examples: [
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type PageInfo {
              hasPreviousPage: Boolean!
              hasNextPage: Boolean!
              startCursor: String
              endCursor: String
            }
          `,
                },
            ],
            isDisabledForAllConfig: true,
            requiresSchema: true,
        },
        messages: {
            [MESSAGE_MUST_EXIST]: 'The server must provide a `PageInfo` object.',
            [MESSAGE_MUST_BE_OBJECT_TYPE$1]: '`PageInfo` must be an Object type.',
        },
        schema: [],
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$9, context);
        if (process.env.NODE_ENV === 'test' || !hasPageInfoChecked) {
            const pageInfoType = schema.getType('PageInfo');
            if (!pageInfoType) {
                context.report({
                    loc: REPORT_ON_FIRST_CHARACTER,
                    messageId: MESSAGE_MUST_EXIST,
                });
            }
            hasPageInfoChecked = true;
        }
        return {
            [notPageInfoTypesSelector](node) {
                context.report({ node, messageId: MESSAGE_MUST_BE_OBJECT_TYPE$1 });
            },
            'ObjectTypeDefinition[name.value=PageInfo]'(node) {
                const fieldMap = Object.fromEntries(node.fields.map(field => [field.name.value, field]));
                const checkField = (fieldName, typeName) => {
                    const field = fieldMap[fieldName];
                    let isAllowedType = false;
                    if (field) {
                        const type = field.gqlType;
                        if (typeName === 'Boolean') {
                            isAllowedType =
                                type.kind === Kind.NON_NULL_TYPE &&
                                    type.gqlType.kind === Kind.NAMED_TYPE &&
                                    type.gqlType.name.value === 'Boolean';
                        }
                        else if (type.kind === Kind.NAMED_TYPE) {
                            isAllowedType = type.name.value === 'String' || isScalarType(schema.getType(type.name.value));
                        }
                    }
                    if (!isAllowedType) {
                        const returnType = typeName === 'Boolean'
                            ? 'non-null Boolean'
                            : 'either String or Scalar, which can be null if there are no results';
                        context.report({
                            node: field ? field.name : node.name,
                            message: field
                                ? `Field \`${fieldName}\` must return ${returnType}.`
                                : `\`PageInfo\` must contain a field \`${fieldName}\`, that return ${returnType}.`,
                        });
                    }
                };
                checkField('hasPreviousPage', 'Boolean');
                checkField('hasNextPage', 'Boolean');
                checkField('startCursor', 'String');
                checkField('endCursor', 'String');
            },
        };
    },
};

const valueFromNode = (...args) => {
    return valueFromASTUntyped(...args);
};
function getBaseType(type) {
    if (isNonNullType(type) || isListType(type)) {
        return getBaseType(type.ofType);
    }
    return type;
}
function convertToken(token, type) {
    const { line, column, end, start, value } = token;
    return {
        type,
        value,
        /*
         * ESLint has 0-based column number
         * https://eslint.org/docs/developer-guide/working-with-rules#contextreport
         */
        loc: {
            start: {
                line,
                column: column - 1,
            },
            end: {
                line,
                column: column - 1 + (end - start),
            },
        },
        range: [start, end],
    };
}
function getLexer(source) {
    // GraphQL v14
    const gqlLanguage = require('graphql/language');
    if (gqlLanguage && gqlLanguage.createLexer) {
        return gqlLanguage.createLexer(source, {});
    }
    // GraphQL v15
    const { Lexer: LexerCls } = require('graphql');
    if (LexerCls && typeof LexerCls === 'function') {
        return new LexerCls(source);
    }
    throw new Error('Unsupported GraphQL version! Please make sure to use GraphQL v14 or newer!');
}
function extractTokens(filePath, code) {
    const source = new Source(code, filePath);
    const lexer = getLexer(source);
    const tokens = [];
    let token = lexer.advance();
    while (token && token.kind !== TokenKind.EOF) {
        const result = convertToken(token, token.kind);
        tokens.push(result);
        token = lexer.advance();
    }
    return tokens;
}
function extractComments(loc) {
    if (!loc) {
        return [];
    }
    const comments = [];
    let token = loc.startToken;
    while (token) {
        if (token.kind === TokenKind.COMMENT) {
            const comment = convertToken(token, 
            // `eslint-disable` directive works only with `Block` type comment
            token.value.trimStart().startsWith('eslint') ? 'Block' : 'Line');
            comments.push(comment);
        }
        token = token.next;
    }
    return comments;
}
function convertLocation(location) {
    const { startToken, endToken, source, start, end } = location;
    /*
     * ESLint has 0-based column number
     * https://eslint.org/docs/developer-guide/working-with-rules#contextreport
     */
    const loc = {
        start: {
            /*
             * Kind.Document has startToken: { line: 0, column: 0 }, we set line as 1 and column as 0
             */
            line: startToken.line === 0 ? 1 : startToken.line,
            column: startToken.column === 0 ? 0 : startToken.column - 1,
        },
        end: {
            line: endToken.line,
            column: endToken.column - 1,
        },
        source: source.body,
    };
    if (loc.start.column === loc.end.column) {
        loc.end.column += end - start;
    }
    return loc;
}

function convertToESTree(node, schema) {
    const typeInfo = schema ? new TypeInfo(schema) : null;
    const visitor = {
        leave(node, key, parent) {
            const leadingComments = 'description' in node && node.description
                ? [
                    {
                        type: node.description.block ? 'Block' : 'Line',
                        value: node.description.value,
                    },
                ]
                : [];
            const calculatedTypeInfo = typeInfo
                ? {
                    argument: typeInfo.getArgument(),
                    defaultValue: typeInfo.getDefaultValue(),
                    directive: typeInfo.getDirective(),
                    enumValue: typeInfo.getEnumValue(),
                    fieldDef: typeInfo.getFieldDef(),
                    inputType: typeInfo.getInputType(),
                    parentInputType: typeInfo.getParentInputType(),
                    parentType: typeInfo.getParentType(),
                    gqlType: typeInfo.getType(),
                }
                : {};
            const rawNode = () => {
                if (parent && key !== undefined) {
                    return parent[key];
                }
                return node.kind === Kind.DOCUMENT
                    ? {
                        ...node,
                        definitions: node.definitions.map(definition => definition.rawNode()),
                    }
                    : node;
            };
            const commonFields = {
                ...node,
                type: node.kind,
                loc: convertLocation(node.loc),
                range: [node.loc.start, node.loc.end],
                leadingComments,
                // Use function to prevent RangeError: Maximum call stack size exceeded
                typeInfo: () => calculatedTypeInfo,
                rawNode,
            };
            return 'type' in node
                ? {
                    ...commonFields,
                    gqlType: node.type,
                }
                : commonFields;
        },
    };
    return visit(node, typeInfo ? visitWithTypeInfo(typeInfo, visitor) : visitor);
}

// eslint-disable-next-line unicorn/better-regex
const DATE_REGEX = /^\d{2}\/\d{2}\/\d{4}$/;
const MESSAGE_REQUIRE_DATE = 'MESSAGE_REQUIRE_DATE';
const MESSAGE_INVALID_FORMAT = 'MESSAGE_INVALID_FORMAT';
const MESSAGE_INVALID_DATE = 'MESSAGE_INVALID_DATE';
const MESSAGE_CAN_BE_REMOVED = 'MESSAGE_CAN_BE_REMOVED';
const rule$j = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Schema',
            description: 'Require deletion date on `@deprecated` directive. Suggest removing deprecated things after deprecated date.',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/require-deprecation-date.md',
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User {
              firstname: String @deprecated
              firstName: String
            }
          `,
                },
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User {
              firstname: String @deprecated(reason: "Use 'firstName' instead")
              firstName: String
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type User {
              firstname: String @deprecated(reason: "Use 'firstName' instead", deletionDate: "25/12/2022")
              firstName: String
            }
          `,
                },
            ],
        },
        messages: {
            [MESSAGE_REQUIRE_DATE]: 'Directive "@deprecated" must have a deletion date',
            [MESSAGE_INVALID_FORMAT]: 'Deletion date must be in format "DD/MM/YYYY"',
            [MESSAGE_INVALID_DATE]: 'Invalid "{{ deletionDate }}" deletion date',
            [MESSAGE_CAN_BE_REMOVED]: '"{{ nodeName }}" сan be removed',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    argumentName: {
                        type: 'string',
                    },
                },
            },
        ],
    },
    create(context) {
        return {
            'Directive[name.value=deprecated]'(node) {
                var _a;
                const argName = ((_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.argumentName) || 'deletionDate';
                const deletionDateNode = node.arguments.find(arg => arg.name.value === argName);
                if (!deletionDateNode) {
                    context.report({
                        node: node.name,
                        messageId: MESSAGE_REQUIRE_DATE,
                    });
                    return;
                }
                const deletionDate = valueFromNode(deletionDateNode.value);
                const isValidDate = DATE_REGEX.test(deletionDate);
                if (!isValidDate) {
                    context.report({ node: deletionDateNode.value, messageId: MESSAGE_INVALID_FORMAT });
                    return;
                }
                let [day, month, year] = deletionDate.split('/');
                day = day.padStart(2, '0');
                month = month.padStart(2, '0');
                const deletionDateInMS = Date.parse(`${year}-${month}-${day}`);
                if (Number.isNaN(deletionDateInMS)) {
                    context.report({
                        node: deletionDateNode.value,
                        messageId: MESSAGE_INVALID_DATE,
                        data: {
                            deletionDate,
                        },
                    });
                    return;
                }
                const canRemove = Date.now() > deletionDateInMS;
                if (canRemove) {
                    const { parent } = node;
                    const nodeName = parent.name.value;
                    context.report({
                        node: parent.name,
                        messageId: MESSAGE_CAN_BE_REMOVED,
                        data: { nodeName },
                        suggest: [
                            {
                                desc: `Remove \`${nodeName}\``,
                                fix: fixer => fixer.remove(parent),
                            },
                        ],
                    });
                }
            },
        };
    },
};

const rule$k = {
    meta: {
        docs: {
            description: 'Require all deprecation directives to specify a reason.',
            category: 'Schema',
            url: 'https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/require-deprecation-reason.md',
            recommended: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type MyType {
              name: String @deprecated
            }
          `,
                },
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type MyType {
              name: String @deprecated(reason: "")
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type MyType {
              name: String @deprecated(reason: "no longer relevant, please use fullName field")
            }
          `,
                },
            ],
        },
        type: 'suggestion',
        schema: [],
    },
    create(context) {
        return {
            'Directive[name.value=deprecated]'(node) {
                const reasonArgument = node.arguments.find(arg => arg.name.value === 'reason');
                const value = reasonArgument && String(valueFromNode(reasonArgument.value)).trim();
                if (!value) {
                    context.report({
                        node: node.name,
                        message: 'Directive "@deprecated" must have a reason!',
                    });
                }
            },
        };
    },
};

const RULE_ID$a = 'require-description';
const ALLOWED_KINDS$1 = [
    ...TYPES_KINDS,
    Kind.DIRECTIVE_DEFINITION,
    Kind.FIELD_DEFINITION,
    Kind.INPUT_VALUE_DEFINITION,
    Kind.ENUM_VALUE_DEFINITION,
    Kind.OPERATION_DEFINITION,
];
function getNodeName(node) {
    const DisplayNodeNameMap = {
        [Kind.OBJECT_TYPE_DEFINITION]: 'type',
        [Kind.INTERFACE_TYPE_DEFINITION]: 'interface',
        [Kind.ENUM_TYPE_DEFINITION]: 'enum',
        [Kind.SCALAR_TYPE_DEFINITION]: 'scalar',
        [Kind.INPUT_OBJECT_TYPE_DEFINITION]: 'input',
        [Kind.UNION_TYPE_DEFINITION]: 'union',
        [Kind.DIRECTIVE_DEFINITION]: 'directive',
    };
    switch (node.kind) {
        case Kind.OBJECT_TYPE_DEFINITION:
        case Kind.INTERFACE_TYPE_DEFINITION:
        case Kind.ENUM_TYPE_DEFINITION:
        case Kind.SCALAR_TYPE_DEFINITION:
        case Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case Kind.UNION_TYPE_DEFINITION:
            return `${DisplayNodeNameMap[node.kind]} ${node.name.value}`;
        case Kind.DIRECTIVE_DEFINITION:
            return `${DisplayNodeNameMap[node.kind]} @${node.name.value}`;
        case Kind.FIELD_DEFINITION:
        case Kind.INPUT_VALUE_DEFINITION:
        case Kind.ENUM_VALUE_DEFINITION:
            return `${node.parent.name.value}.${node.name.value}`;
        case Kind.OPERATION_DEFINITION:
            return node.name ? `${node.operation} ${node.name.value}` : node.operation;
    }
}
const rule$l = {
    meta: {
        docs: {
            category: 'Schema',
            description: 'Enforce descriptions in type definitions and operations.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$a}.md`,
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ types: true, FieldDefinition: true }],
                    code: /* GraphQL */ `
            type someTypeName {
              name: String
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ types: true, FieldDefinition: true }],
                    code: /* GraphQL */ `
            """
            Some type description
            """
            type someTypeName {
              """
              Name description
              """
              name: String
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ OperationDefinition: true }],
                    code: /* GraphQL */ `
            # Create a new user
            mutation createUser {
              # ...
            }
          `,
                },
            ],
            configOptions: [
                {
                    types: true,
                    [Kind.DIRECTIVE_DEFINITION]: true,
                },
            ],
            recommended: true,
        },
        type: 'suggestion',
        messages: {
            [RULE_ID$a]: 'Description is required for `{{ nodeName }}`.',
        },
        schema: {
            type: 'array',
            minItems: 1,
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                minProperties: 1,
                properties: {
                    types: {
                        type: 'boolean',
                        description: `Includes:\n\n${TYPES_KINDS.map(kind => `- \`${kind}\``).join('\n')}`,
                    },
                    ...Object.fromEntries([...ALLOWED_KINDS$1].sort().map(kind => {
                        let description = `Read more about this kind on [spec.graphql.org](https://spec.graphql.org/October2021/#${kind}).`;
                        if (kind === Kind.OPERATION_DEFINITION) {
                            description += '\n\n> You must use only comment syntax `#` and not description syntax `"""` or `"`.';
                        }
                        return [kind, { type: 'boolean', description }];
                    })),
                },
            },
        },
    },
    create(context) {
        const { types, ...restOptions } = context.options[0] || {};
        const kinds = new Set(types ? TYPES_KINDS : []);
        for (const [kind, isEnabled] of Object.entries(restOptions)) {
            if (isEnabled) {
                kinds.add(kind);
            }
            else {
                kinds.delete(kind);
            }
        }
        const selector = [...kinds].join(',');
        return {
            [selector](node) {
                var _a;
                let description = '';
                const isOperation = node.kind === Kind.OPERATION_DEFINITION;
                if (isOperation) {
                    const rawNode = node.rawNode();
                    const { prev, line } = rawNode.loc.startToken;
                    if (prev.kind === TokenKind.COMMENT) {
                        const value = prev.value.trim();
                        const linesBefore = line - prev.line;
                        if (!value.startsWith('eslint') && linesBefore === 1) {
                            description = value;
                        }
                    }
                }
                else {
                    description = ((_a = node.description) === null || _a === void 0 ? void 0 : _a.value.trim()) || '';
                }
                if (description.length === 0) {
                    context.report({
                        loc: isOperation ? getLocation(node.loc.start, node.operation) : node.name.loc,
                        messageId: RULE_ID$a,
                        data: {
                            nodeName: getNodeName(node),
                        },
                    });
                }
            },
        };
    },
};

const RULE_ID$b = 'require-field-of-type-query-in-mutation-result';
const rule$m = {
    meta: {
        type: 'suggestion',
        docs: {
            category: 'Schema',
            description: 'Allow the client in one round-trip not only to call mutation but also to get a wagon of data to update their application.\n> Currently, no errors are reported for result type `union`, `interface` and `scalar`.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$b}.md`,
            requiresSchema: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            type User { ... }

            type Mutation {
              createUser: User!
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            type User { ... }

            type Query { ... }

            type CreateUserPayload {
              user: User!
              query: Query!
            }

            type Mutation {
              createUser: CreateUserPayload!
            }
          `,
                },
            ],
        },
        schema: [],
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$b, context);
        const mutationType = schema.getMutationType();
        const queryType = schema.getQueryType();
        if (!mutationType || !queryType) {
            return {};
        }
        const selector = `:matches(ObjectTypeDefinition, ObjectTypeExtension)[name.value=${mutationType.name}] > FieldDefinition > .gqlType Name`;
        return {
            [selector](node) {
                const typeName = node.value;
                const graphQLType = schema.getType(typeName);
                if (isObjectType$1(graphQLType)) {
                    const { fields } = graphQLType.astNode;
                    const hasQueryType = fields.some(field => getTypeName(field) === queryType.name);
                    if (!hasQueryType) {
                        context.report({
                            node,
                            message: `Mutation result type "${graphQLType.name}" must contain field of type "${queryType.name}"`,
                        });
                    }
                }
            },
        };
    },
};

const RULE_ID$c = 'require-id-when-available';
const DEFAULT_ID_FIELD_NAME = 'id';
const rule$n = {
    meta: {
        type: 'suggestion',
        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions
        hasSuggestions: true,
        docs: {
            category: 'Operations',
            description: 'Enforce selecting specific fields when they are available on the GraphQL type.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$c}.md`,
            requiresSchema: true,
            requiresSiblings: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            # In your schema
            type User {
              id: ID!
              name: String!
            }

            # Query
            query {
              user {
                name
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            # In your schema
            type User {
              id: ID!
              name: String!
            }

            # Query
            query {
              user {
                id
                name
              }
            }

            # Selecting \`id\` with an alias is also valid
            query {
              user {
                id: name
              }
            }
          `,
                },
            ],
            recommended: true,
        },
        messages: {
            [RULE_ID$c]: "Field{{ pluralSuffix }} {{ fieldName }} must be selected when it's available on a type.\nInclude it in your selection set{{ addition }}.",
        },
        schema: {
            definitions: {
                asString: {
                    type: 'string',
                },
                asArray: ARRAY_DEFAULT_OPTIONS,
            },
            type: 'array',
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                properties: {
                    fieldName: {
                        oneOf: [{ $ref: '#/definitions/asString' }, { $ref: '#/definitions/asArray' }],
                        default: DEFAULT_ID_FIELD_NAME,
                    },
                },
            },
        },
    },
    create(context) {
        const schema = requireGraphQLSchemaFromContext(RULE_ID$c, context);
        const siblings = requireSiblingsOperations(RULE_ID$c, context);
        const { fieldName = DEFAULT_ID_FIELD_NAME } = context.options[0] || {};
        const idNames = asArray(fieldName);
        // Check selections only in OperationDefinition,
        // skip selections of OperationDefinition and InlineFragment
        const selector = 'OperationDefinition SelectionSet[parent.kind!=/(^OperationDefinition|InlineFragment)$/]';
        const typeInfo = new TypeInfo(schema);
        function checkFragments(node) {
            for (const selection of node.selections) {
                if (selection.kind !== Kind.FRAGMENT_SPREAD) {
                    continue;
                }
                const [foundSpread] = siblings.getFragment(selection.name.value);
                if (!foundSpread) {
                    continue;
                }
                const checkedFragmentSpreads = new Set();
                const visitor = visitWithTypeInfo(typeInfo, {
                    SelectionSet(node, key, parent) {
                        if (parent.kind === Kind.FRAGMENT_DEFINITION) {
                            checkedFragmentSpreads.add(parent.name.value);
                        }
                        else if (parent.kind !== Kind.INLINE_FRAGMENT) {
                            checkSelections(node, typeInfo.getType(), selection.loc.start, parent, checkedFragmentSpreads);
                        }
                    },
                });
                visit(foundSpread.document, visitor);
            }
        }
        function checkSelections(node, type, 
        // Fragment can be placed in separate file
        // Provide actual fragment spread location instead of location in fragment
        loc, 
        // Can't access to node.parent in GraphQL AST.Node, so pass as argument
        parent, checkedFragmentSpreads = new Set()) {
            const rawType = getBaseType(type);
            const isObjectType = rawType instanceof GraphQLObjectType;
            const isInterfaceType = rawType instanceof GraphQLInterfaceType;
            if (!isObjectType && !isInterfaceType) {
                return;
            }
            const fields = rawType.getFields();
            const hasIdFieldInType = idNames.some(name => fields[name]);
            if (!hasIdFieldInType) {
                return;
            }
            function hasIdField({ selections }) {
                return selections.some(selection => {
                    if (selection.kind === Kind.FIELD) {
                        if (selection.alias && idNames.includes(selection.alias.value)) {
                            return true;
                        }
                        return idNames.includes(selection.name.value);
                    }
                    if (selection.kind === Kind.INLINE_FRAGMENT) {
                        return hasIdField(selection.selectionSet);
                    }
                    if (selection.kind === Kind.FRAGMENT_SPREAD) {
                        const [foundSpread] = siblings.getFragment(selection.name.value);
                        if (foundSpread) {
                            const fragmentSpread = foundSpread.document;
                            checkedFragmentSpreads.add(fragmentSpread.name.value);
                            return hasIdField(fragmentSpread.selectionSet);
                        }
                    }
                    return false;
                });
            }
            const hasId = hasIdField(node);
            checkFragments(node);
            if (hasId) {
                return;
            }
            const pluralSuffix = idNames.length > 1 ? 's' : '';
            const fieldName = englishJoinWords(idNames.map(name => `\`${(parent.alias || parent.name).value}.${name}\``));
            const addition = checkedFragmentSpreads.size === 0
                ? ''
                : ` or add to used fragment${checkedFragmentSpreads.size > 1 ? 's' : ''} ${englishJoinWords([...checkedFragmentSpreads].map(name => `\`${name}\``))}`;
            const problem = {
                loc,
                messageId: RULE_ID$c,
                data: {
                    pluralSuffix,
                    fieldName,
                    addition,
                },
            };
            // Don't provide suggestions for selections in fragments as fragment can be in a separate file
            if ('type' in node) {
                problem.suggest = idNames.map(idName => ({
                    desc: `Add \`${idName}\` selection`,
                    fix: fixer => fixer.insertTextBefore(node.selections[0], `${idName} `),
                }));
            }
            context.report(problem);
        }
        return {
            [selector](node) {
                const typeInfo = node.typeInfo();
                if (typeInfo.gqlType) {
                    checkSelections(node, typeInfo.gqlType, node.loc.start, node.parent);
                }
            },
        };
    },
};

const RULE_ID$d = 'selection-set-depth';
const rule$o = {
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        docs: {
            category: 'Operations',
            description: 'Limit the complexity of the GraphQL operations solely by their depth. Based on [graphql-depth-limit](https://npmjs.com/package/graphql-depth-limit).',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$d}.md`,
            requiresSiblings: true,
            examples: [
                {
                    title: 'Incorrect',
                    usage: [{ maxDepth: 1 }],
                    code: `
            query deep2 {
              viewer { # Level 0
                albums { # Level 1
                  title # Level 2
                }
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [{ maxDepth: 4 }],
                    code: `
            query deep2 {
              viewer { # Level 0
                albums { # Level 1
                  title # Level 2
                }
              }
            }
          `,
                },
                {
                    title: 'Correct (ignored field)',
                    usage: [{ maxDepth: 1, ignore: ['albums'] }],
                    code: `
            query deep2 {
              viewer { # Level 0
                albums { # Level 1
                  title # Level 2
                }
              }
            }
          `,
                },
            ],
            recommended: true,
            configOptions: [{ maxDepth: 7 }],
        },
        schema: {
            type: 'array',
            minItems: 1,
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                required: ['maxDepth'],
                properties: {
                    maxDepth: {
                        type: 'number',
                    },
                    ignore: ARRAY_DEFAULT_OPTIONS,
                },
            },
        },
    },
    create(context) {
        let siblings = null;
        try {
            siblings = requireSiblingsOperations(RULE_ID$d, context);
        }
        catch (_a) {
            logger.warn(`Rule "${RULE_ID$d}" works best with siblings operations loaded. For more info: https://bit.ly/graphql-eslint-operations`);
        }
        const { maxDepth, ignore = [] } = context.options[0];
        const checkFn = depthLimit(maxDepth, { ignore });
        return {
            'OperationDefinition, FragmentDefinition'(node) {
                try {
                    const rawNode = node.rawNode();
                    const fragmentsInUse = siblings ? siblings.getFragmentsInUse(rawNode) : [];
                    const document = {
                        kind: Kind.DOCUMENT,
                        definitions: [rawNode, ...fragmentsInUse],
                    };
                    checkFn({
                        getDocument: () => document,
                        reportError(error) {
                            const { line, column } = error.locations[0];
                            context.report({
                                loc: {
                                    line,
                                    column: column - 1,
                                },
                                message: error.message,
                                suggest: [
                                    {
                                        desc: 'Remove selections',
                                        fix(fixer) {
                                            const ancestors = context.getAncestors();
                                            const token = ancestors[0].tokens.find(token => token.loc.start.line === line && token.loc.start.column === column - 1);
                                            const sourceCode = context.getSourceCode();
                                            const foundNode = sourceCode.getNodeByRangeIndex(token.range[0]);
                                            const parentNode = foundNode.parent.parent;
                                            return fixer.remove(foundNode.kind === 'Name' ? parentNode.parent : parentNode);
                                        },
                                    },
                                ],
                            });
                        },
                    });
                }
                catch (e) {
                    logger.warn(`Rule "${RULE_ID$d}" check failed due to a missing siblings operations. For more info: https://bit.ly/graphql-eslint-operations`, e);
                }
            },
        };
    },
};

const RULE_ID$e = 'strict-id-in-types';
const rule$p = {
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Requires output types to have one unique identifier unless they do not have a logical one. Exceptions can be used to ignore output types that do not have unique identifiers.',
            category: 'Schema',
            recommended: true,
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$e}.md`,
            requiresSchema: true,
            examples: [
                {
                    title: 'Incorrect',
                    usage: [
                        {
                            acceptedIdNames: ['id', '_id'],
                            acceptedIdTypes: ['ID'],
                            exceptions: { suffixes: ['Payload'] },
                        },
                    ],
                    code: /* GraphQL */ `
            # Incorrect field name
            type InvalidFieldName {
              key: ID!
            }

            # Incorrect field type
            type InvalidFieldType {
              id: String!
            }

            # Incorrect exception suffix
            type InvalidSuffixResult {
              data: String!
            }

            # Too many unique identifiers. Must only contain one.
            type InvalidFieldName {
              id: ID!
              _id: ID!
            }
          `,
                },
                {
                    title: 'Correct',
                    usage: [
                        {
                            acceptedIdNames: ['id', '_id'],
                            acceptedIdTypes: ['ID'],
                            exceptions: { types: ['Error'], suffixes: ['Payload'] },
                        },
                    ],
                    code: /* GraphQL */ `
            type User {
              id: ID!
            }

            type Post {
              _id: ID!
            }

            type CreateUserPayload {
              data: String!
            }

            type Error {
              message: String!
            }
          `,
                },
            ],
        },
        schema: {
            type: 'array',
            maxItems: 1,
            items: {
                type: 'object',
                additionalProperties: false,
                properties: {
                    acceptedIdNames: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        default: ['id'],
                    },
                    acceptedIdTypes: {
                        ...ARRAY_DEFAULT_OPTIONS,
                        default: ['ID'],
                    },
                    exceptions: {
                        type: 'object',
                        properties: {
                            types: {
                                ...ARRAY_DEFAULT_OPTIONS,
                                description: 'This is used to exclude types with names that match one of the specified values.',
                            },
                            suffixes: {
                                ...ARRAY_DEFAULT_OPTIONS,
                                description: 'This is used to exclude types with names with suffixes that match one of the specified values.',
                            },
                        },
                    },
                },
            },
        },
    },
    create(context) {
        const options = {
            acceptedIdNames: ['id'],
            acceptedIdTypes: ['ID'],
            exceptions: {},
            ...context.options[0],
        };
        const schema = requireGraphQLSchemaFromContext(RULE_ID$e, context);
        const rootTypeNames = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()]
            .filter(Boolean)
            .map(type => type.name);
        const selector = `ObjectTypeDefinition[name.value!=/^(${rootTypeNames.join('|')})$/]`;
        return {
            [selector](node) {
                var _a, _b;
                const typeName = node.name.value;
                const shouldIgnoreNode = ((_a = options.exceptions.types) === null || _a === void 0 ? void 0 : _a.includes(typeName)) ||
                    ((_b = options.exceptions.suffixes) === null || _b === void 0 ? void 0 : _b.some(suffix => typeName.endsWith(suffix)));
                if (shouldIgnoreNode) {
                    return;
                }
                const validIds = node.fields.filter(field => {
                    const fieldNode = field.rawNode();
                    const isValidIdName = options.acceptedIdNames.includes(fieldNode.name.value);
                    // To be a valid type, it must be non-null and one of the accepted types.
                    let isValidIdType = false;
                    if (fieldNode.type.kind === Kind.NON_NULL_TYPE && fieldNode.type.type.kind === Kind.NAMED_TYPE) {
                        isValidIdType = options.acceptedIdTypes.includes(fieldNode.type.type.name.value);
                    }
                    return isValidIdName && isValidIdType;
                });
                // Usually, there should be only one unique identifier field per type.
                // Some clients allow multiple fields to be used. If more people need this,
                // we can extend this rule later.
                if (validIds.length !== 1) {
                    const pluralNamesSuffix = options.acceptedIdNames.length > 1 ? 's' : '';
                    const pluralTypesSuffix = options.acceptedIdTypes.length > 1 ? 's' : '';
                    context.report({
                        node: node.name,
                        message: `${typeName} must have exactly one non-nullable unique identifier. Accepted name${pluralNamesSuffix}: ${englishJoinWords(options.acceptedIdNames)}. Accepted type${pluralTypesSuffix}: ${englishJoinWords(options.acceptedIdTypes)}.`,
                    });
                }
            },
        };
    },
};

const RULE_ID$f = 'unique-fragment-name';
const checkNode = (context, node, ruleId) => {
    const documentName = node.name.value;
    const siblings = requireSiblingsOperations(ruleId, context);
    const siblingDocuments = node.kind === Kind.FRAGMENT_DEFINITION ? siblings.getFragment(documentName) : siblings.getOperation(documentName);
    const filepath = context.getFilename();
    const conflictingDocuments = siblingDocuments.filter(f => {
        var _a;
        const isSameName = ((_a = f.document.name) === null || _a === void 0 ? void 0 : _a.value) === documentName;
        const isSamePath = normalizePath(f.filePath) === normalizePath(filepath);
        return isSameName && !isSamePath;
    });
    if (conflictingDocuments.length > 0) {
        context.report({
            messageId: ruleId,
            data: {
                documentName,
                summary: conflictingDocuments
                    .map(f => `\t${relative(process.cwd(), getOnDiskFilepath(f.filePath))}`)
                    .join('\n'),
            },
            node: node.name,
        });
    }
};
const rule$q = {
    meta: {
        type: 'suggestion',
        docs: {
            category: 'Operations',
            description: 'Enforce unique fragment names across your project.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$f}.md`,
            requiresSiblings: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            # user.fragment.graphql
            fragment UserFields on User {
              id
              name
              fullName
            }

            # user-fields.graphql
            fragment UserFields on User {
              id
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            # user.fragment.graphql
            fragment AllUserFields on User {
              id
              name
              fullName
            }

            # user-fields.graphql
            fragment UserFields on User {
              id
            }
          `,
                },
            ],
        },
        messages: {
            [RULE_ID$f]: 'Fragment named "{{ documentName }}" already defined in:\n{{ summary }}',
        },
        schema: [],
    },
    create(context) {
        return {
            FragmentDefinition(node) {
                checkNode(context, node, RULE_ID$f);
            },
        };
    },
};

const RULE_ID$g = 'unique-operation-name';
const rule$r = {
    meta: {
        type: 'suggestion',
        docs: {
            category: 'Operations',
            description: 'Enforce unique operation names across your project.',
            url: `https://github.com/B2o5T/graphql-eslint/blob/master/docs/rules/${RULE_ID$g}.md`,
            requiresSiblings: true,
            examples: [
                {
                    title: 'Incorrect',
                    code: /* GraphQL */ `
            # foo.query.graphql
            query user {
              user {
                id
              }
            }

            # bar.query.graphql
            query user {
              me {
                id
              }
            }
          `,
                },
                {
                    title: 'Correct',
                    code: /* GraphQL */ `
            # foo.query.graphql
            query user {
              user {
                id
              }
            }

            # bar.query.graphql
            query me {
              me {
                id
              }
            }
          `,
                },
            ],
        },
        messages: {
            [RULE_ID$g]: 'Operation named "{{ documentName }}" already defined in:\n{{ summary }}',
        },
        schema: [],
    },
    create(context) {
        return {
            'OperationDefinition[name!=undefined]'(node) {
                checkNode(context, node, RULE_ID$g);
            },
        };
    },
};

/*
 * 🚨 IMPORTANT! Do not manually modify this file. Run: `yarn generate-configs`
 */
const rules = {
    ...GRAPHQL_JS_VALIDATIONS,
    alphabetize: rule,
    'description-style': rule$1,
    'input-name': rule$2,
    'match-document-filename': rule$3,
    'naming-convention': rule$4,
    'no-anonymous-operations': rule$5,
    'no-case-insensitive-enum-values-duplicates': rule$6,
    'no-deprecated': rule$7,
    'no-duplicate-fields': rule$8,
    'no-hashtag-description': rule$9,
    'no-root-type': rule$a,
    'no-scalar-result-type-on-mutation': rule$b,
    'no-typename-prefix': rule$c,
    'no-unreachable-types': rule$d,
    'no-unused-fields': rule$e,
    'relay-arguments': rule$f,
    'relay-connection-types': rule$g,
    'relay-edge-types': rule$h,
    'relay-page-info': rule$i,
    'require-deprecation-date': rule$j,
    'require-deprecation-reason': rule$k,
    'require-description': rule$l,
    'require-field-of-type-query-in-mutation-result': rule$m,
    'require-id-when-available': rule$n,
    'selection-set-depth': rule$o,
    'strict-id-in-types': rule$p,
    'unique-fragment-name': rule$q,
    'unique-operation-name': rule$r,
};

const schemaCache = new Map();
const debug = debugFactory('graphql-eslint:schema');
function getSchema(projectForFile, options = {}) {
    const schemaKey = asArray(projectForFile.schema).sort().join(',');
    if (!schemaKey) {
        return null;
    }
    if (schemaCache.has(schemaKey)) {
        return schemaCache.get(schemaKey);
    }
    let schema;
    try {
        debug('Loading schema from %o', projectForFile.schema);
        schema = projectForFile.loadSchemaSync(projectForFile.schema, 'GraphQLSchema', options.schemaOptions);
        if (debug.enabled) {
            debug('Schema loaded: %o', schema instanceof GraphQLSchema);
            const schemaPaths = fastGlob.sync(projectForFile.schema, {
                absolute: true,
            });
            debug('Schema pointers %O', schemaPaths);
        }
    }
    catch (error) {
        error.message = chalk.red(`Error while loading schema: ${error.message}`);
        schema = error;
    }
    schemaCache.set(schemaKey, schema);
    return schema;
}

const debug$1 = debugFactory('graphql-eslint:operations');
const handleVirtualPath = (documents) => {
    const filepathMap = Object.create(null);
    return documents.map(source => {
        var _a;
        const { location } = source;
        if (['.gql', '.graphql'].some(extension => location.endsWith(extension))) {
            return source;
        }
        (_a = filepathMap[location]) !== null && _a !== void 0 ? _a : (filepathMap[location] = -1);
        const index = (filepathMap[location] += 1);
        return {
            ...source,
            location: resolve(location, `${index}_document.graphql`),
        };
    });
};
const operationsCache = new Map();
const siblingOperationsCache = new Map();
const getSiblings = (projectForFile) => {
    const documentsKey = asArray(projectForFile.documents).sort().join(',');
    if (!documentsKey) {
        return [];
    }
    let siblings = operationsCache.get(documentsKey);
    if (!siblings) {
        debug$1('Loading operations from %o', projectForFile.documents);
        const documents = projectForFile.loadDocumentsSync(projectForFile.documents, {
            skipGraphQLImport: true,
        });
        if (debug$1.enabled) {
            debug$1('Loaded %d operations', documents.length);
            const operationsPaths = fastGlob.sync(projectForFile.documents, {
                absolute: true,
            });
            debug$1('Operations pointers %O', operationsPaths);
        }
        siblings = handleVirtualPath(documents);
        operationsCache.set(documentsKey, siblings);
    }
    return siblings;
};
function getSiblingOperations(projectForFile) {
    const siblings = getSiblings(projectForFile);
    if (siblings.length === 0) {
        let printed = false;
        const noopWarn = () => {
            if (!printed) {
                logger.warn('getSiblingOperations was called without any operations. Make sure to set "parserOptions.operations" to make this feature available!');
                printed = true;
            }
            return [];
        };
        return {
            available: false,
            getFragment: noopWarn,
            getFragments: noopWarn,
            getFragmentByType: noopWarn,
            getFragmentsInUse: noopWarn,
            getOperation: noopWarn,
            getOperations: noopWarn,
            getOperationByType: noopWarn,
        };
    }
    // Since the siblings array is cached, we can use it as cache key.
    // We should get the same array reference each time we get
    // to this point for the same graphql project
    if (siblingOperationsCache.has(siblings)) {
        return siblingOperationsCache.get(siblings);
    }
    let fragmentsCache = null;
    const getFragments = () => {
        if (fragmentsCache === null) {
            const result = [];
            for (const source of siblings) {
                for (const definition of source.document.definitions) {
                    if (definition.kind === Kind.FRAGMENT_DEFINITION) {
                        result.push({
                            filePath: source.location,
                            document: definition,
                        });
                    }
                }
            }
            fragmentsCache = result;
        }
        return fragmentsCache;
    };
    let cachedOperations = null;
    const getOperations = () => {
        if (cachedOperations === null) {
            const result = [];
            for (const source of siblings) {
                for (const definition of source.document.definitions) {
                    if (definition.kind === Kind.OPERATION_DEFINITION) {
                        result.push({
                            filePath: source.location,
                            document: definition,
                        });
                    }
                }
            }
            cachedOperations = result;
        }
        return cachedOperations;
    };
    const getFragment = (name) => getFragments().filter(f => { var _a; return ((_a = f.document.name) === null || _a === void 0 ? void 0 : _a.value) === name; });
    const collectFragments = (selectable, recursive, collected = new Map()) => {
        visit(selectable, {
            FragmentSpread(spread) {
                const fragmentName = spread.name.value;
                const [fragment] = getFragment(fragmentName);
                if (!fragment) {
                    logger.warn(`Unable to locate fragment named "${fragmentName}", please make sure it's loaded using "parserOptions.operations"`);
                    return;
                }
                if (!collected.has(fragmentName)) {
                    collected.set(fragmentName, fragment.document);
                    if (recursive) {
                        collectFragments(fragment.document, recursive, collected);
                    }
                }
            },
        });
        return collected;
    };
    const siblingOperations = {
        available: true,
        getFragment,
        getFragments,
        getFragmentByType: typeName => getFragments().filter(f => { var _a, _b; return ((_b = (_a = f.document.typeCondition) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value) === typeName; }),
        getFragmentsInUse: (selectable, recursive = true) => Array.from(collectFragments(selectable, recursive).values()),
        getOperation: name => getOperations().filter(o => { var _a; return ((_a = o.document.name) === null || _a === void 0 ? void 0 : _a.value) === name; }),
        getOperations,
        getOperationByType: type => getOperations().filter(o => o.document.operation === type),
    };
    siblingOperationsCache.set(siblings, siblingOperations);
    return siblingOperations;
}

const debug$2 = debugFactory('graphql-eslint:graphql-config');
let graphQLConfig;
function loadGraphQLConfig(options) {
    // We don't want cache config on test environment
    // Otherwise schema and documents will be same for all tests
    if (process.env.NODE_ENV !== 'test' && graphQLConfig) {
        return graphQLConfig;
    }
    const onDiskConfig = options.skipGraphQLConfig
        ? null
        : loadConfigSync({
            // load config relative to the file being linted
            rootDir: options.filePath ? dirname(options.filePath) : undefined,
            throwOnEmpty: false,
            throwOnMissing: false,
            extensions: [addCodeFileLoaderExtension],
        });
    debug$2('options.skipGraphQLConfig: %o', options.skipGraphQLConfig);
    if (onDiskConfig) {
        debug$2('Graphql-config path %o', onDiskConfig.filepath);
    }
    const configOptions = options.projects
        ? { projects: options.projects }
        : {
            schema: (options.schema || ''),
            documents: options.documents || options.operations,
            extensions: options.extensions,
            include: options.include,
            exclude: options.exclude,
        };
    graphQLConfig =
        onDiskConfig ||
            new GraphQLConfig({
                config: configOptions,
                filepath: 'virtual-config',
            }, [addCodeFileLoaderExtension]);
    return graphQLConfig;
}
const addCodeFileLoaderExtension = api => {
    api.loaders.schema.register(new CodeFileLoader());
    api.loaders.documents.register(new CodeFileLoader());
    return { name: 'graphql-eslint-loaders' };
};

const debug$3 = debugFactory('graphql-eslint:parser');
debug$3('cwd %o', process.cwd());
function parseForESLint(code, options = {}) {
    try {
        const filePath = options.filePath || '';
        const realFilepath = filePath && getOnDiskFilepath(filePath);
        const gqlConfig = loadGraphQLConfig(options);
        const projectForFile = realFilepath ? gqlConfig.getProjectForFile(realFilepath) : gqlConfig.getDefault();
        const schema = getSchema(projectForFile, options);
        const siblingOperations = getSiblingOperations(projectForFile);
        const { document } = parseGraphQLSDL(filePath, code, {
            ...options.graphQLParserOptions,
            noLocation: false,
        });
        const comments = extractComments(document.loc);
        const tokens = extractTokens(filePath, code);
        const rootTree = convertToESTree(document, schema instanceof GraphQLSchema ? schema : null);
        return {
            services: {
                schema,
                siblingOperations,
            },
            ast: {
                comments,
                tokens,
                loc: rootTree.loc,
                range: rootTree.range,
                type: 'Program',
                sourceType: 'script',
                body: [rootTree],
            },
        };
    }
    catch (error) {
        error.message = `[graphql-eslint] ${error.message}`;
        // In case of GraphQL parser error, we report it to ESLint as a parser error that matches the requirements
        // of ESLint. This will make sure to display it correctly in IDEs and lint results.
        if (error instanceof GraphQLError) {
            const eslintError = {
                index: error.positions[0],
                lineNumber: error.locations[0].line,
                column: error.locations[0].column,
                message: error.message,
            };
            throw eslintError;
        }
        throw error;
    }
}

/* eslint-env jest */
function indentCode(code, indent = 4) {
    return code.replace(/^/gm, ' '.repeat(indent));
}
// A simple version of `SourceCodeFixer.applyFixes`
// https://github.com/eslint/eslint/issues/14936#issuecomment-906746754
function applyFix(code, { range, text }) {
    return [code.slice(0, range[0]), text, code.slice(range[1])].join('');
}
class GraphQLRuleTester extends RuleTester {
    constructor(parserOptions = {}) {
        const config = {
            parser: require.resolve('@graphql-eslint/eslint-plugin'),
            parserOptions: {
                ...parserOptions,
                skipGraphQLConfig: true,
            },
        };
        super(config);
        this.config = config;
    }
    fromMockFile(path) {
        return readFileSync(resolve(__dirname, `../tests/mocks/${path}`), 'utf-8');
    }
    runGraphQLTests(ruleId, rule, tests) {
        const ruleTests = Linter.version.startsWith('8')
            ? tests
            : {
                valid: tests.valid.map(test => {
                    if (typeof test === 'string') {
                        return test;
                    }
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { name, ...testCaseOptions } = test;
                    return testCaseOptions;
                }),
                invalid: tests.invalid.map(test => {
                    // ESLint 7 throws an error on CI - Unexpected top-level property "name"
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { name, ...testCaseOptions } = test;
                    return testCaseOptions;
                }),
            };
        super.run(ruleId, rule, ruleTests);
        const linter = new Linter();
        linter.defineRule(ruleId, rule);
        const hasOnlyTest = [...tests.valid, ...tests.invalid].some(t => typeof t !== 'string' && t.only);
        // for (const [index, testCase] of tests.valid.entries()) {
        //   const { name, code, filename, only }: RuleTester.ValidTestCase =
        //     typeof testCase === 'string' ? { code: testCase } : testCase;
        //
        //   if (hasOnlyTest && !only) {
        //     continue;
        //   }
        //
        //   const verifyConfig = getVerifyConfig(ruleId, this.config, testCase);
        //   defineParser(linter, verifyConfig.parser);
        //
        //   const messages = linter.verify(code, verifyConfig, { filename });
        //   const codeFrame = printCode(code, { line: 0, column: 0 });
        //
        //   it(name || `Valid #${index + 1}\n${codeFrame}`, () => {
        //     expect(messages).toEqual([]);
        //   });
        // }
        for (const [idx, testCase] of tests.invalid.entries()) {
            const { only, filename, options, name } = testCase;
            if (hasOnlyTest && !only) {
                continue;
            }
            const code = removeTrailingBlankLines(testCase.code);
            const verifyConfig = getVerifyConfig(ruleId, this.config, testCase);
            defineParser(linter, verifyConfig.parser);
            const messages = linter.verify(code, verifyConfig, filename);
            if (messages.length === 0) {
                throw new Error('Invalid case should have at least one error.');
            }
            const codeFrame = indentCode(printCode(code, { line: 0, column: 0 }));
            const messageForSnapshot = ['#### ⌨️ Code', codeFrame];
            if (options) {
                const opts = JSON.stringify(options, null, 2).slice(1, -1);
                messageForSnapshot.push('#### ⚙️ Options', indentCode(removeTrailingBlankLines(opts), 2));
            }
            for (const [index, message] of messages.entries()) {
                if (message.fatal) {
                    throw new Error(message.message);
                }
                const codeWithMessage = printCode(code, message, 1);
                messageForSnapshot.push(printWithIndex('#### ❌ Error', index, messages.length), indentCode(codeWithMessage));
                const { suggestions } = message;
                // Don't print suggestions in snapshots for too big codes
                if (suggestions && (code.match(/\n/g) || '').length < 1000) {
                    for (const [i, suggestion] of message.suggestions.entries()) {
                        const title = printWithIndex('#### 💡 Suggestion', i, suggestions.length, suggestion.desc);
                        const output = applyFix(code, suggestion.fix);
                        const codeFrame = printCode(output, { line: 0, column: 0 });
                        messageForSnapshot.push(title, indentCode(codeFrame, 2));
                    }
                }
            }
            if (rule.meta.fixable) {
                const { fixed, output } = linter.verifyAndFix(code, verifyConfig, filename);
                if (fixed) {
                    messageForSnapshot.push('#### 🔧 Autofix output', indentCode(printCode(output)));
                }
            }
            it(name || `Invalid #${idx + 1}`, () => {
                expect(messageForSnapshot.join('\n\n')).toMatchSnapshot();
            });
        }
    }
}
function removeTrailingBlankLines(text) {
    return text.replace(/^\s*\n/, '').trimEnd();
}
function printWithIndex(title, index, total, description) {
    if (total > 1) {
        title += ` ${index + 1}/${total}`;
    }
    if (description) {
        title += `: ${description}`;
    }
    return title;
}
function getVerifyConfig(ruleId, testerConfig, testCase) {
    const { parser = testerConfig.parser, parserOptions, options } = testCase;
    return {
        ...testerConfig,
        parser,
        parserOptions: {
            ...testerConfig.parserOptions,
            ...parserOptions,
        },
        rules: {
            [ruleId]: Array.isArray(options) ? ['error', ...options] : 'error',
        },
    };
}
const parsers = new WeakMap();
function defineParser(linter, parser) {
    if (!parser) {
        return;
    }
    if (!parsers.has(linter)) {
        parsers.set(linter, new Set());
    }
    const defined = parsers.get(linter);
    if (!defined.has(parser)) {
        defined.add(parser);
        linter.defineParser(parser, require(parser));
    }
}
function printCode(code, result = {}, linesOffset = Number.POSITIVE_INFINITY) {
    const { line, column, endLine, endColumn, message } = result;
    const location = {};
    if (typeof line === 'number' && typeof column === 'number') {
        location.start = {
            line,
            column,
        };
    }
    if (typeof endLine === 'number' && typeof endColumn === 'number') {
        location.end = {
            line: endLine,
            column: endColumn,
        };
    }
    return codeFrameColumns(code, location, {
        linesAbove: linesOffset,
        linesBelow: linesOffset,
        message,
    });
}

const processors = { graphql: processor };
const configs = Object.fromEntries([
    // Configs to extend from `configs` directory
    'schema-recommended',
    'schema-all',
    'operations-recommended',
    'operations-all',
    'relay',
].map(configName => [configName, { extends: `./configs/${configName}.json` }]));

export { GraphQLRuleTester, configs, parseForESLint, processors, requireGraphQLSchemaFromContext, requireSiblingsOperations, rules };
